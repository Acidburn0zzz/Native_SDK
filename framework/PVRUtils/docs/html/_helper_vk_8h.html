<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRUtils: /usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRUtils/Vulkan/HelperVk.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_687531cb5acd5e736601deea3ef3b7c0.html">SDK</a></li><li class="navelem"><a class="el" href="dir_407ce59cc93389552d4bbf4df897abf8.html">framework</a></li><li class="navelem"><a class="el" href="dir_56a6b2806f907a59546ae220133253ab.html">PVRUtils</a></li><li class="navelem"><a class="el" href="dir_2a4e396b2e69f22c2b04ad2a158af6a3.html">Vulkan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HelperVk.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains helper functions for several common complicated Vulkan tasks, such as swapchain creation and texture uploading.  
<a href="#details">More...</a></p>

<p><a href="_helper_vk_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">pvr::utils::DebugUtilsCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper structure which provides a more abstract representation of a set of debug utils messengers or debug callbacks when using either VK_EXT_debug_utils or VK_EXT_debug_report respectively. <a href="structpvr_1_1utils_1_1_debug_utils_callbacks.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">pvr::utils::DeviceExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of device extensions to be used for initiailising a device using the helper function 'createDeviceAndQueues'. <a href="structpvr_1_1utils_1_1_device_extensions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_image_update_info.html">pvr::utils::ImageUpdateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html" title="The ImageUpdateInfo struct.">ImageUpdateInfo</a> struct. <a href="structpvr_1_1utils_1_1_image_update_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">pvr::utils::InstanceExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of instance extensions to be used for initiailising an instance using the helper function 'createInstanceAndSurface'. <a href="structpvr_1_1utils_1_1_instance_extensions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">pvr::utils::InstanceLayers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of instance layers to be used for initiailising an instance using the helper function 'createInstanceAndSurface'. <a href="structpvr_1_1utils_1_1_instance_layers.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html">pvr::utils::QueueAccessInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating the family id and queue id of a particular queue retrieved via the helper function 'createDeviceAndQueues'. The family id corresponds to the family id the queue was retrieved from. The queue id corresponds to the particular queue index for the retrieved queue. <a href="structpvr_1_1utils_1_1_queue_access_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html">pvr::utils::QueuePopulateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating the set of queue flags required for a particular queue retrieved via the helper function 'createDeviceAndQueues'. Optionally additionally providing a surface will indicate that the queue must support presentation via the provided surface. <a href="structpvr_1_1utils_1_1_queue_populate_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">pvr::utils::VertexBindings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Explicit binding, tying a Semantic name to an Attribute Index. <a href="structpvr_1_1utils_1_1_vertex_bindings.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">pvr::utils::VertexBindings_Name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name. <a href="structpvr_1_1utils_1_1_vertex_bindings___name.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">pvr::utils::VulkanVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html" title="The VulkanVersion structure provides an easy mechanism for constructing the Vulkan version for use wh...">VulkanVersion</a> structure provides an easy mechanism for constructing the Vulkan version for use when creating a Vulkan instance. <a href="structpvr_1_1utils_1_1_vulkan_version.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepvr"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html">pvr</a></td></tr>
<tr class="memdesc:namespacepvr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main PowerVR Framework namespace<br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1utils"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html">pvr::utils</a></td></tr>
<tr class="memdesc:namespacepvr_1_1utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main namespace for the PVRUtils Library <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="memTemplParams" colspan="2">template&lt;typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac66fa9a9c7f8232c3f5aa3f41106cfea">pvr::utils::appendSingleBuffersFromModel</a> (pvrvk::Device &amp;device, const assets::Model &amp;model, VboContainer_ &amp;vbos, IboContainer_ &amp;ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user. <a href="#ac66fa9a9c7f8232c3f5aa3f41106cfea">More...</a><br/></td></tr>
<tr class="separator:ac66fa9a9c7f8232c3f5aa3f41106cfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f241ba112200732fffaeb2906b6ed4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">pvr::utils::beginCommandBufferDebugLabel</a> (pvrvk::CommandBufferBase commandBufferBase, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a3f241ba112200732fffaeb2906b6ed4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. <a href="#a3f241ba112200732fffaeb2906b6ed4b">More...</a><br/></td></tr>
<tr class="separator:a3f241ba112200732fffaeb2906b6ed4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab62f121a7b8a9d790ca4e4e3dfcff0aa">pvr::utils::beginCommandBufferDebugLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. <a href="#ab62f121a7b8a9d790ca4e4e3dfcff0aa">More...</a><br/></td></tr>
<tr class="separator:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dc67a22e33dc6bf735edc27a1432ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a45dc67a22e33dc6bf735edc27a1432ef">pvr::utils::beginCommandBufferDebugLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a45dc67a22e33dc6bf735edc27a1432ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this secondary command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. <a href="#a45dc67a22e33dc6bf735edc27a1432ef">More...</a><br/></td></tr>
<tr class="separator:a45dc67a22e33dc6bf735edc27a1432ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaec27096b06e097a3ead372e30c68c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7eaec27096b06e097a3ead372e30c68c">pvr::utils::beginQueueDebugLabel</a> (pvrvk::Queue queue, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a7eaec27096b06e097a3ead372e30c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this queue. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. <a href="#a7eaec27096b06e097a3ead372e30c68c">More...</a><br/></td></tr>
<tr class="separator:a7eaec27096b06e097a3ead372e30c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e26711ea2633048564188b42d62f11b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1e26711ea2633048564188b42d62f11b">pvr::utils::captureImageRegion</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Image &amp;image, pvrvk::Offset3D srcOffset=pvrvk::Offset3D(0, 0, 0), pvrvk::Extent3D srcExtent=pvrvk::Extent3D(-1,-1,-1), pvrvk::Format destinationImageFormat=pvrvk::Format::e_UNDEFINED, pvrvk::ImageLayout imageInitialLayout=pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL, pvrvk::ImageLayout imageFinalLayout=pvrvk::ImageLayout::e_TRANSFER_DST_OPTIMAL, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr)</td></tr>
<tr class="memdesc:a1e26711ea2633048564188b42d62f11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and returns the contents of a particular image region. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set. <a href="#a1e26711ea2633048564188b42d62f11b">More...</a><br/></td></tr>
<tr class="separator:a1e26711ea2633048564188b42d62f11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad0c9ce4267ec635305fc87aba0b9d9c2">pvr::utils::create3dPlaneMesh</a> (uint32_t width, uint32_t depth, bool generateTexCoords, bool generateNormalCoords, assets::Mesh &amp;outMesh)</td></tr>
<tr class="memdesc:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3d plane mesh based on the width and depth specified. Texture coordinates and normal coordinates can also optionally be generated based on the generateTexCoords and generateNormalCoords flags respectively. The generated mesh will be returned as a pvr::assets::Mesh. <a href="#ad0c9ce4267ec635305fc87aba0b9d9c2">More...</a><br/></td></tr>
<tr class="separator:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecac80786da19a6303dbf72345c16a9"><td class="memItemLeft" align="right" valign="top">pvrvk::Buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acecac80786da19a6303dbf72345c16a9">pvr::utils::createBuffer</a> (pvrvk::Device device, VkDeviceSize size, pvrvk::BufferUsageFlags bufferUsage, pvrvk::MemoryPropertyFlags requiredMemoryFlags, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT, pvrvk::BufferCreateFlags bufferCreateFlags=pvrvk::BufferCreateFlags(0), pvrvk::SharingMode sharingMode=pvrvk::SharingMode::e_EXCLUSIVE, const uint32_t *queueFamilyIndices=nullptr, uint32_t numQueueFamilyIndices=0)</td></tr>
<tr class="memdesc:acecac80786da19a6303dbf72345c16a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer object and (optionally) allocate and bind memory for it <a href="#acecac80786da19a6303dbf72345c16a9">More...</a><br/></td></tr>
<tr class="separator:acecac80786da19a6303dbf72345c16a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="memItemLeft" align="right" valign="top">DebugUtilsCallbacks&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3c7a82ad08f5f77c574a75fc1c4eca9a">pvr::utils::createDebugUtilsCallbacks</a> (pvrvk::Instance &amp;instance)</td></tr>
<tr class="memdesc:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a default set of debug utils messengers or debug callbacks using either VK_EXT_debug_utils or VK_EXT_debug_report respectively. The first callback will trigger an exception to be thrown when an error message is returned. The second callback will Log a message for errors and warnings. <a href="#a3c7a82ad08f5f77c574a75fc1c4eca9a">More...</a><br/></td></tr>
<tr class="separator:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34226196d1cd435e8f19abecc2d3b0eb"><td class="memItemLeft" align="right" valign="top">pvrvk::Device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a34226196d1cd435e8f19abecc2d3b0eb">pvr::utils::createDeviceAndQueues</a> (pvrvk::PhysicalDevice physicalDevice, const QueuePopulateInfo *queueCreateInfos, uint32_t numQueueCreateInfos, QueueAccessInfo *outAccessInfo, const DeviceExtensions &amp;deviceExtensions=DeviceExtensions())</td></tr>
<tr class="memdesc:a34226196d1cd435e8f19abecc2d3b0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the pvrvk::Device and the queues <a href="#a34226196d1cd435e8f19abecc2d3b0eb">More...</a><br/></td></tr>
<tr class="separator:a34226196d1cd435e8f19abecc2d3b0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea80135aa97006c881f5d3fface1563"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2ea80135aa97006c881f5d3fface1563">pvr::utils::createImage</a> (pvrvk::Device device, pvrvk::ImageType imageType, pvrvk::Format format, const pvrvk::Extent3D &amp;dimension, pvrvk::ImageUsageFlags usage, pvrvk::ImageCreateFlags flags=pvrvk::ImageCreateFlags(0), const pvrvk::ImageLayersSize &amp;layerSize=pvrvk::ImageLayersSize(), pvrvk::SampleCountFlags samples=pvrvk::SampleCountFlags::e_1_BIT, pvrvk::MemoryPropertyFlags requiredMemoryFlags=pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE, pvrvk::SharingMode sharingMode=pvrvk::SharingMode::e_EXCLUSIVE, pvrvk::ImageTiling tiling=pvrvk::ImageTiling::e_OPTIMAL, pvrvk::ImageLayout initialLayout=pvrvk::ImageLayout::e_UNDEFINED, const uint32_t *queueFamilyIndices=nullptr, uint32_t numQueueFamilyIndices=0)</td></tr>
<tr class="memdesc:a2ea80135aa97006c881f5d3fface1563"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new Image(sparse or with memory backing, depending on <em>flags</em> . The user should not call bindMemory on the image if sparse flags are used. <em>requiredMemoryFlags</em>  is ignored if <em>flags</em>  contains sparse binding flags. <a href="#a2ea80135aa97006c881f5d3fface1563">More...</a><br/></td></tr>
<tr class="separator:a2ea80135aa97006c881f5d3fface1563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ef5943947e565f7d14aa9ff0393d9"><td class="memItemLeft" align="right" valign="top">pvrvk::Instance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a680ef5943947e565f7d14aa9ff0393d9">pvr::utils::createInstance</a> (const std::string &amp;applicationName, VulkanVersion apiVersion=VulkanVersion(), const InstanceExtensions &amp;instanceExtensions=InstanceExtensions(), const InstanceLayers &amp;instanceLayers=InstanceLayers())</td></tr>
<tr class="memdesc:a680ef5943947e565f7d14aa9ff0393d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating a Vulkan instance and supported physical devices using the appropriately set parameters. <a href="#a680ef5943947e565f7d14aa9ff0393d9">More...</a><br/></td></tr>
<tr class="separator:a680ef5943947e565f7d14aa9ff0393d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e0a5be7c444548e52a74c2f40faaa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a95e0a5be7c444548e52a74c2f40faaa5">pvr::utils::createMultipleBuffersFromMesh</a> (pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, std::vector&lt; pvrvk::Buffer &gt; &amp;outVbos, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a95e0a5be7c444548e52a74c2f40faaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh. <a href="#a95e0a5be7c444548e52a74c2f40faaa5">More...</a><br/></td></tr>
<tr class="separator:a95e0a5be7c444548e52a74c2f40faaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c27cb705f0f371580caad44b5763be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af3c27cb705f0f371580caad44b5763be">pvr::utils::createOnscreenFramebufferAndRenderPass</a> (pvrvk::Swapchain &amp;swapchain, pvrvk::ImageView *depthStencilImages, Multi&lt; pvrvk::Framebuffer &gt; &amp;outFramebuffers, pvrvk::RenderPass &amp;outRenderPass, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::AttachmentLoadOp colorLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp=pvrvk::AttachmentStoreOp::e_STORE, pvrvk::AttachmentLoadOp depthStencilLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp=pvrvk::AttachmentStoreOp::e_DONT_CARE)</td></tr>
<tr class="memdesc:af3c27cb705f0f371580caad44b5763be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Framebuffer and RenderPass to use for 'default' rendering to the 'onscreen' color images with following config RenderPass: Attachment0: ColorAttachment swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store Attachment1: DepthStencilAttachment finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store <a href="#af3c27cb705f0f371580caad44b5763be">More...</a><br/></td></tr>
<tr class="separator:af3c27cb705f0f371580caad44b5763be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800aecef7aa17bc651e2ee97b8e2c6d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a800aecef7aa17bc651e2ee97b8e2c6d9">pvr::utils::createOnscreenFramebufferAndRenderPass</a> (pvrvk::Swapchain &amp;swapchain, pvrvk::ImageView *depthStencilImages, Multi&lt; pvrvk::Framebuffer &gt; &amp;outFramebuffers, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::AttachmentLoadOp colorLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp=pvrvk::AttachmentStoreOp::e_STORE, pvrvk::AttachmentLoadOp depthStencilLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp=pvrvk::AttachmentStoreOp::e_DONT_CARE)</td></tr>
<tr class="memdesc:a800aecef7aa17bc651e2ee97b8e2c6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Framebuffer and RenderPass to use for 'default' rendering to the 'onscreen' color images with following config RenderPass: ColorAttachment0: swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store DepthStencilAttachment: finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store Subpass0 <a href="#a800aecef7aa17bc651e2ee97b8e2c6d9">More...</a><br/></td></tr>
<tr class="separator:a800aecef7aa17bc651e2ee97b8e2c6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6934715b675cba2e0a7454813b431a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae6934715b675cba2e0a7454813b431a3">pvr::utils::createSingleBuffersFromMesh</a> (pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, pvrvk::Buffer &amp;outVbo, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:ae6934715b675cba2e0a7454813b431a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a single VBO and a single IBO from all the vertex data of a mesh. <a href="#ae6934715b675cba2e0a7454813b431a3">More...</a><br/></td></tr>
<tr class="separator:ae6934715b675cba2e0a7454813b431a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f94be9a865755c8bafaac56f286b01"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a06f94be9a865755c8bafaac56f286b01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a06f94be9a865755c8bafaac56f286b01">pvr::utils::createSingleBuffersFromMeshes</a> (pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboInsertIterator_ outVbos, IboInsertIterator_ outIbos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a06f94be9a865755c8bafaac56f286b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container. <a href="#a06f94be9a865755c8bafaac56f286b01">More...</a><br/></td></tr>
<tr class="separator:a06f94be9a865755c8bafaac56f286b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4493b0c69e45e8b7af4d2fa32f763f23">pvr::utils::createSingleBuffersFromMeshes</a> (pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboContainer_ &amp;outVbos, typename VboContainer_::iterator vbos_where, IboContainer_ &amp;outIbos, typename IboContainer_::iterator ibos_where, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container. <a href="#a4493b0c69e45e8b7af4d2fa32f763f23">More...</a><br/></td></tr>
<tr class="separator:a4493b0c69e45e8b7af4d2fa32f763f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b77d306417876f431ed11fffde3a84f"><td class="memTemplParams" colspan="2">template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a8b77d306417876f431ed11fffde3a84f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8b77d306417876f431ed11fffde3a84f">pvr::utils::createSingleBuffersFromModel</a> (pvrvk::Device &amp;device, const assets::Model &amp;model, VboInsertIterator_ vbos, IboInsertIterator_ ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a8b77d306417876f431ed11fffde3a84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters. <a href="#a8b77d306417876f431ed11fffde3a84f">More...</a><br/></td></tr>
<tr class="separator:a8b77d306417876f431ed11fffde3a84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa583027696be258fc78dd3156ffaece5"><td class="memItemLeft" align="right" valign="top">pvrvk::Surface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aa583027696be258fc78dd3156ffaece5">pvr::utils::createSurface</a> (pvrvk::Instance &amp;instance, pvrvk::PhysicalDevice &amp;physicalDevice, void *window, void *display)</td></tr>
<tr class="memdesc:aa583027696be258fc78dd3156ffaece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract vulkan native platform surface. <a href="#aa583027696be258fc78dd3156ffaece5">More...</a><br/></td></tr>
<tr class="separator:aa583027696be258fc78dd3156ffaece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d992b548d4b9d5617bc2766f1dbdda9"><td class="memItemLeft" align="right" valign="top">pvrvk::Swapchain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3d992b548d4b9d5617bc2766f1dbdda9">pvr::utils::createSwapchain</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, const std::vector&lt; pvrvk::Format &gt; &amp;preferredColorFormats=std::vector&lt; pvrvk::Format &gt;(), pvrvk::ImageUsageFlags swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT)</td></tr>
<tr class="memdesc:a3d992b548d4b9d5617bc2766f1dbdda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color format of the swapchain images created from the specified list of preferred color formats. <a href="#a3d992b548d4b9d5617bc2766f1dbdda9">More...</a><br/></td></tr>
<tr class="separator:a3d992b548d4b9d5617bc2766f1dbdda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb02e95824004b5bf3b80049ec0a3e40"><td class="memItemLeft" align="right" valign="top">pvrvk::Swapchain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acb02e95824004b5bf3b80049ec0a3e40">pvr::utils::createSwapchain</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::ImageUsageFlags swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT)</td></tr>
<tr class="memdesc:acb02e95824004b5bf3b80049ec0a3e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface. <a href="#acb02e95824004b5bf3b80049ec0a3e40">More...</a><br/></td></tr>
<tr class="separator:acb02e95824004b5bf3b80049ec0a3e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391224081fe950b01072c76a7a33fbac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a391224081fe950b01072c76a7a33fbac">pvr::utils::createSwapchainAndDepthStencilImageAndViews</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::Swapchain &amp;outSwapchain, Multi&lt; pvrvk::ImageView &gt; &amp;outDepthStencilImages, const std::vector&lt; pvrvk::Format &gt; &amp;preferredColorFormats=std::vector&lt; pvrvk::Format &gt;(), const std::vector&lt; pvrvk::Format &gt; &amp;preferredDepthStencilFormats=std::vector&lt; pvrvk::Format &gt;(), const pvrvk::ImageUsageFlags &amp;swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const pvrvk::ImageUsageFlags &amp;dsImageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, vma::Allocator *dsImageAllocator=nullptr, vma::AllocationCreateFlags dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</td></tr>
<tr class="memdesc:a391224081fe950b01072c76a7a33fbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color and depth stencil format of the images created from the specified list of preferred color and depth stencil formats. <a href="#a391224081fe950b01072c76a7a33fbac">More...</a><br/></td></tr>
<tr class="separator:a391224081fe950b01072c76a7a33fbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4cbed57981943e18958f5d6708caac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#afb4cbed57981943e18958f5d6708caac">pvr::utils::createSwapchainAndDepthStencilImageAndViews</a> (pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::Swapchain &amp;outSwapchain, Multi&lt; pvrvk::ImageView &gt; &amp;outDepthStencilImages, const pvrvk::ImageUsageFlags &amp;swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const pvrvk::ImageUsageFlags &amp;dsImageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, vma::Allocator *dsImageAllocator=nullptr, vma::AllocationCreateFlags dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</td></tr>
<tr class="memdesc:afb4cbed57981943e18958f5d6708caac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pvrvk::Device and pvrvk::Surface. <a href="#afb4cbed57981943e18958f5d6708caac">More...</a><br/></td></tr>
<tr class="separator:afb4cbed57981943e18958f5d6708caac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e6adce5bcec23564fd67553c9f4088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">pvr::utils::endCommandBufferDebugLabel</a> (pvrvk::CommandBufferBase commandBufferBase)</td></tr>
<tr class="memdesc:a12e6adce5bcec23564fd67553c9f4088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this base command buffer. <a href="#a12e6adce5bcec23564fd67553c9f4088">More...</a><br/></td></tr>
<tr class="separator:a12e6adce5bcec23564fd67553c9f4088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da693f264b2b719a77fc84bf0a32ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2da693f264b2b719a77fc84bf0a32ec5">pvr::utils::endCommandBufferDebugLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer)</td></tr>
<tr class="memdesc:a2da693f264b2b719a77fc84bf0a32ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this command buffer. <a href="#a2da693f264b2b719a77fc84bf0a32ec5">More...</a><br/></td></tr>
<tr class="separator:a2da693f264b2b719a77fc84bf0a32ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee1c88c7937b7a16127e810b75b2ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adee1c88c7937b7a16127e810b75b2ab7">pvr::utils::endCommandBufferDebugLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer)</td></tr>
<tr class="memdesc:adee1c88c7937b7a16127e810b75b2ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this secondary command buffer. <a href="#adee1c88c7937b7a16127e810b75b2ab7">More...</a><br/></td></tr>
<tr class="separator:adee1c88c7937b7a16127e810b75b2ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605300322093e44b7cd509533f14b4fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a605300322093e44b7cd509533f14b4fa">pvr::utils::endQueueDebugLabel</a> (pvrvk::Queue queue)</td></tr>
<tr class="memdesc:a605300322093e44b7cd509533f14b4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this queue. <a href="#a605300322093e44b7cd509533f14b4fa">More...</a><br/></td></tr>
<tr class="separator:a605300322093e44b7cd509533f14b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3d1522b9db9f69b91090f918ccc8c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5d3d1522b9db9f69b91090f918ccc8c0">pvr::utils::generateTextureAtlas</a> (pvrvk::Device &amp;device, const pvrvk::Image *inputImages, pvrvk::Rect2Df *outUVs, uint32_t numImages, pvrvk::ImageLayout inputImageLayout, pvrvk::ImageView *outImageView, TextureHeader *outDescriptor, pvrvk::CommandBufferBase cmdBuffer, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a5d3d1522b9db9f69b91090f918ccc8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for generating a texture atlas based on a set of images. <a href="#a5d3d1522b9db9f69b91090f918ccc8c0">More...</a><br/></td></tr>
<tr class="separator:a5d3d1522b9db9f69b91090f918ccc8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ce1f5bcf625224715988176c3519a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a56ce1f5bcf625224715988176c3519a2">pvr::utils::getColorBits</a> (pvrvk::Format format, uint32_t &amp;redBits, uint32_t &amp;greenBits, uint32_t &amp;blueBits, uint32_t &amp;alphaBits)</td></tr>
<tr class="memdesc:a56ce1f5bcf625224715988176c3519a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of color bits per pixel for the given pvrvk::Format. <a href="#a56ce1f5bcf625224715988176c3519a2">More...</a><br/></td></tr>
<tr class="separator:a56ce1f5bcf625224715988176c3519a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcac1e9af1869244329d12c291200a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1bcac1e9af1869244329d12c291200a5">pvr::utils::getDepthStencilBits</a> (pvrvk::Format format, uint32_t &amp;depthBits, uint32_t &amp;stencilBits)</td></tr>
<tr class="memdesc:a1bcac1e9af1869244329d12c291200a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of depth and stencil bits per pixel for the given pvrvk::Format. <a href="#a1bcac1e9af1869244329d12c291200a5">More...</a><br/></td></tr>
<tr class="separator:a1bcac1e9af1869244329d12c291200a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6bbf98fde377992e9e7e0d23f38a9dcc">pvr::utils::getMemoryTypeIndex</a> (const pvrvk::PhysicalDevice &amp;physicalDevice, const uint32_t allowedMemoryTypeBits, const pvrvk::MemoryPropertyFlags requiredMemoryProperties, const pvrvk::MemoryPropertyFlags optimalMemoryProperties, uint32_t &amp;outMemoryTypeIndex, pvrvk::MemoryPropertyFlags &amp;outMemoryPropertyFlags)</td></tr>
<tr class="memdesc:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for retrieving a memory type index for a suitable memory type which supports the memory type bits specified. If the optimal set of memory properties are supported then return the corresponding memory type index otherwise check for availablility of the required set of memory properties. This allows for implementations to optionally request the use of a more optimal set of memory properties whilst still preserving the ability to retrieve the required set of memory properties as a fallback. <a href="#a6bbf98fde377992e9e7e0d23f38a9dcc">More...</a><br/></td></tr>
<tr class="separator:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2d4df80d31e3e63923ab1d68152ace"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7b2d4df80d31e3e63923ab1d68152ace">pvr::utils::getNumSamplesFromSampleCountFlags</a> (pvrvk::SampleCountFlags sampleCountFlags)</td></tr>
<tr class="memdesc:a7b2d4df80d31e3e63923ab1d68152ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert pvrvk sample count to the number of samples it is equivalent to <a href="#a7b2d4df80d31e3e63923ab1d68152ace">More...</a><br/></td></tr>
<tr class="separator:a7b2d4df80d31e3e63923ab1d68152ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3555f264beaaf83ff1b84853a87a40fe"><td class="memItemLeft" align="right" valign="top">glm::mat4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3555f264beaaf83ff1b84853a87a40fe">pvr::utils::getPerspectiveMatrix</a> (float fovy, float aspect, float near1, float far1, float rotate=.0f)</td></tr>
<tr class="memdesc:a3555f264beaaf83ff1b84853a87a40fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create perspective matrix that trasform scenes that use Opengl Convention (+y up) to Vulkan Convention (+y down). <a href="#a3555f264beaaf83ff1b84853a87a40fe">More...</a><br/></td></tr>
<tr class="separator:a3555f264beaaf83ff1b84853a87a40fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93735fa36d5aedc03cf746dfa208a4b5"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageAspectFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a93735fa36d5aedc03cf746dfa208a4b5">pvr::utils::inferAspectFromFormat</a> (pvrvk::Format format)</td></tr>
<tr class="memdesc:a93735fa36d5aedc03cf746dfa208a4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infers the pvrvk::ImageAspectFlags from the pvrvk::Format. <a href="#a93735fa36d5aedc03cf746dfa208a4b5">More...</a><br/></td></tr>
<tr class="separator:a93735fa36d5aedc03cf746dfa208a4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3adba7320aa2b924adc48cfa5e043ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">pvr::utils::insertDebugUtilsLabel</a> (pvrvk::CommandBufferBase commandBufferBase, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ae3adba7320aa2b924adc48cfa5e043ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time. <a href="#ae3adba7320aa2b924adc48cfa5e043ed">More...</a><br/></td></tr>
<tr class="separator:ae3adba7320aa2b924adc48cfa5e043ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab77d5528ee9f9dc1f4dda381175b89eb">pvr::utils::insertDebugUtilsLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time. <a href="#ab77d5528ee9f9dc1f4dda381175b89eb">More...</a><br/></td></tr>
<tr class="separator:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2938b3543ae68e23f0f2eb348a786ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2938b3543ae68e23f0f2eb348a786ae9">pvr::utils::insertDebugUtilsLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a2938b3543ae68e23f0f2eb348a786ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time. <a href="#a2938b3543ae68e23f0f2eb348a786ae9">More...</a><br/></td></tr>
<tr class="separator:a2938b3543ae68e23f0f2eb348a786ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7151c7b74ff657fc17ff09c0ab114a07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07">pvr::utils::isFormatDepthStencil</a> (pvrvk::Format format)</td></tr>
<tr class="memdesc:a7151c7b74ff657fc17ff09c0ab114a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the format is a depth stencil format <a href="#a7151c7b74ff657fc17ff09c0ab114a07">More...</a><br/></td></tr>
<tr class="separator:a7151c7b74ff657fc17ff09c0ab114a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59222cc49624a76fab4d4f65e3337ac3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a59222cc49624a76fab4d4f65e3337ac3">pvr::utils::isImageUsageSupportedBySurface</a> (const pvrvk::SurfaceCapabilitiesKHR &amp;surfaceCapabilities, pvrvk::ImageUsageFlags imageUsage)</td></tr>
<tr class="memdesc:a59222cc49624a76fab4d4f65e3337ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used to determine whether the SurfaceCapabilitiesKHR supportedUsageFlags member contains the specified image usage and therefore can be used in the intended way. <a href="#a59222cc49624a76fab4d4f65e3337ac3">More...</a><br/></td></tr>
<tr class="separator:a59222cc49624a76fab4d4f65e3337ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf319f2a39bf8149f2c8c4b36b1382a"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a9bf319f2a39bf8149f2c8c4b36b1382a">pvr::utils::loadAndUploadImage</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a9bf319f2a39bf8149f2c8c4b36b1382a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a9bf319f2a39bf8149f2c8c4b36b1382a">More...</a><br/></td></tr>
<tr class="separator:a9bf319f2a39bf8149f2c8c4b36b1382a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88581dc8fdfc8d1f32d8a272e5c24a75"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a88581dc8fdfc8d1f32d8a272e5c24a75">pvr::utils::loadAndUploadImage</a> (pvrvk::Device &amp;device, const std::string &amp;fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a88581dc8fdfc8d1f32d8a272e5c24a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a88581dc8fdfc8d1f32d8a272e5c24a75">More...</a><br/></td></tr>
<tr class="separator:a88581dc8fdfc8d1f32d8a272e5c24a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13b551250f56033c7e3c17e67602ad6"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae13b551250f56033c7e3c17e67602ad6">pvr::utils::loadAndUploadImage</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ae13b551250f56033c7e3c17e67602ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#ae13b551250f56033c7e3c17e67602ad6">More...</a><br/></td></tr>
<tr class="separator:ae13b551250f56033c7e3c17e67602ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7010e7802edc5e1cc101034ac386d37"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad7010e7802edc5e1cc101034ac386d37">pvr::utils::loadAndUploadImageAndView</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ad7010e7802edc5e1cc101034ac386d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#ad7010e7802edc5e1cc101034ac386d37">More...</a><br/></td></tr>
<tr class="separator:ad7010e7802edc5e1cc101034ac386d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fd64515fccd74310bb74070b669339"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab1fd64515fccd74310bb74070b669339">pvr::utils::loadAndUploadImageAndView</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ab1fd64515fccd74310bb74070b669339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#ab1fd64515fccd74310bb74070b669339">More...</a><br/></td></tr>
<tr class="separator:ab1fd64515fccd74310bb74070b669339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbbbd1665449ea70d772de63595c806"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">pvr::utils::logMessageDebugReportCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</td></tr>
<tr class="memdesc:a1cbbbd1665449ea70d772de63595c806"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugReportCallback function providing logging for various events. <a href="#a1cbbbd1665449ea70d772de63595c806">More...</a><br/></td></tr>
<tr class="separator:a1cbbbd1665449ea70d772de63595c806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5e37e4f2f8723d81f2f60ff7c9ffebdf">pvr::utils::logMessageDebugUtilsMessengerCallback</a> (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</td></tr>
<tr class="memdesc:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugUtilsMessengerCallback function providing logging for various events. <a href="#a5e37e4f2f8723d81f2f60ff7c9ffebdf">More...</a><br/></td></tr>
<tr class="separator:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee21903727c73558ad8e3cf936917344"><td class="memItemLeft" align="right" valign="top">LogLevel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aee21903727c73558ad8e3cf936917344">pvr::utils::mapDebugReportFlagsToLogLevel</a> (pvrvk::DebugReportFlagsEXT flags)</td></tr>
<tr class="memdesc:aee21903727c73558ad8e3cf936917344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a set of DebugReportFlagsEXT to a particular type of log message. <a href="#aee21903727c73558ad8e3cf936917344">More...</a><br/></td></tr>
<tr class="separator:aee21903727c73558ad8e3cf936917344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd1f30f49a0d36c9d932437e902d2bb"><td class="memItemLeft" align="right" valign="top">LogLevel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abbd1f30f49a0d36c9d932437e902d2bb">pvr::utils::mapDebugUtilsMessageSeverityFlagsToLogLevel</a> (pvrvk::DebugUtilsMessageSeverityFlagsEXT flags)</td></tr>
<tr class="memdesc:abbd1f30f49a0d36c9d932437e902d2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a set of DebugUtilsMessageSeverityFlagsEXT to a particular type of log message. <a href="#abbd1f30f49a0d36c9d932437e902d2bb">More...</a><br/></td></tr>
<tr class="separator:abbd1f30f49a0d36c9d932437e902d2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a98e4ac9990af6eaf6b9bf0928f2bd07d">pvr::utils::populateClearValues</a> (const pvrvk::RenderPass &amp;renderpass, const pvrvk::ClearValue &amp;clearColor, const pvrvk::ClearValue &amp;clearDepthStencilValue, pvrvk::ClearValue *outClearValues)</td></tr>
<tr class="memdesc:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate color and depthstencil clear values <a href="#a98e4ac9990af6eaf6b9bf0928f2bd07d">More...</a><br/></td></tr>
<tr class="separator:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae0c2fd1a13ff3b5e9086e13ea4608c43">pvr::utils::populateInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const VertexBindings *bindingMap, uint16_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint16_t *numOutBuffers=nullptr)</td></tr>
<tr class="memdesc:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a>. <a href="#ae0c2fd1a13ff3b5e9086e13ea4608c43">More...</a><br/></td></tr>
<tr class="separator:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4a65db2498eb2d073a7af233bb1367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5b4a65db2498eb2d073a7af233bb1367">pvr::utils::populateInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const VertexBindings_Name *bindingMap, uint16_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint16_t *numOutBuffers=nullptr)</td></tr>
<tr class="memdesc:a5b4a65db2498eb2d073a7af233bb1367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name...">VertexBindings_Name</a>. <a href="#a5b4a65db2498eb2d073a7af233bb1367">More...</a><br/></td></tr>
<tr class="separator:a5b4a65db2498eb2d073a7af233bb1367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1e9a18d03439c5efe7d88dbb3c16b783">pvr::utils::populateViewportStateCreateInfo</a> (const pvrvk::Framebuffer &amp;framebuffer, pvrvk::PipelineViewportStateCreateInfo &amp;outCreateInfo)</td></tr>
<tr class="memdesc:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out a pvrvk::ViewportStateCreateInfo structure setting parameters for a 'default' viewport and scissor based on the specified frame buffer dimensions. <a href="#a1e9a18d03439c5efe7d88dbb3c16b783">More...</a><br/></td></tr>
<tr class="separator:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd56ceb5a0ccd36437b833a00a1bd9c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acd56ceb5a0ccd36437b833a00a1bd9c5">pvr::utils::saveImage</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Image &amp;image, const pvrvk::ImageLayout imageInitialLayout, const pvrvk::ImageLayout imageFinalLayout, const std::string &amp;filename, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, const uint32_t screenshotScale=1)</td></tr>
<tr class="memdesc:acd56ceb5a0ccd36437b833a00a1bd9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the input image as a TGA file with the filename specified. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set. <a href="#acd56ceb5a0ccd36437b833a00a1bd9c5">More...</a><br/></td></tr>
<tr class="separator:acd56ceb5a0ccd36437b833a00a1bd9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076fe31eafd575f7f2a10f27f6130935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a076fe31eafd575f7f2a10f27f6130935">pvr::utils::setImageLayout</a> (pvrvk::Image &amp;image, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::CommandBufferBase transitionCmdBuffer)</td></tr>
<tr class="memdesc:a076fe31eafd575f7f2a10f27f6130935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image layout <a href="#a076fe31eafd575f7f2a10f27f6130935">More...</a><br/></td></tr>
<tr class="separator:a076fe31eafd575f7f2a10f27f6130935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f7af5558e7afc812edc1e8899d8f50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a19f7af5558e7afc812edc1e8899d8f50">pvr::utils::setImageLayoutAndQueueFamilyOwnership</a> (pvrvk::CommandBufferBase srccmd, pvrvk::CommandBufferBase dstcmd, uint32_t srcQueueFamily, uint32_t dstQueueFamily, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::Image &amp;image, uint32_t baseMipLevel, uint32_t numMipLevels, uint32_t baseArrayLayer, uint32_t numArrayLayers, pvrvk::ImageAspectFlags aspect)</td></tr>
<tr class="memdesc:a19f7af5558e7afc812edc1e8899d8f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image layout and queue family ownership <a href="#a19f7af5558e7afc812edc1e8899d8f50">More...</a><br/></td></tr>
<tr class="separator:a19f7af5558e7afc812edc1e8899d8f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af132fea9e3e9e5b4bc87004a4228096a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af132fea9e3e9e5b4bc87004a4228096a">pvr::utils::takeScreenshot</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Swapchain &amp;swapchain, const uint32_t swapIndex, const std::string &amp;screenshotFileName, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, const uint32_t screenshotScale=1)</td></tr>
<tr class="memdesc:af132fea9e3e9e5b4bc87004a4228096a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a particular swapchain image corresponding to the swapchain image at index swapIndex for the swapchain. <a href="#af132fea9e3e9e5b4bc87004a4228096a">More...</a><br/></td></tr>
<tr class="separator:af132fea9e3e9e5b4bc87004a4228096a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2bb511b50d2c11ddc7377a60714ad"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a54f2bb511b50d2c11ddc7377a60714ad">pvr::utils::throwOnErrorDebugReportCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</td></tr>
<tr class="memdesc:a54f2bb511b50d2c11ddc7377a60714ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugReportCallback function providing logging for various events. The callback will also throw an exception when VkDebugReportFlagsEXT includes the VK_DEBUG_REPORT_ERROR_BIT_EXT. <a href="#a54f2bb511b50d2c11ddc7377a60714ad">More...</a><br/></td></tr>
<tr class="separator:a54f2bb511b50d2c11ddc7377a60714ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3d187bfb119271fea887f28268699a"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aaf3d187bfb119271fea887f28268699a">pvr::utils::throwOnErrorDebugUtilsMessengerCallback</a> (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</td></tr>
<tr class="memdesc:aaf3d187bfb119271fea887f28268699a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugUtilsMessengerCallback function providing logging for various events. The callback will also throw an exception when VkDebugUtilsMessageSeverityFlagBitsEXT includes the VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT. <a href="#aaf3d187bfb119271fea887f28268699a">More...</a><br/></td></tr>
<tr class="separator:aaf3d187bfb119271fea887f28268699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac885b6f537cb86c114be6696c3dc2fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">pvr::utils::updateBufferUsingStagingBuffer</a> (pvrvk::Device &amp;device, pvrvk::Buffer &amp;buffer, pvrvk::CommandBufferBase uploadCmdBuffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, vma::Allocator *stagingBufferAllocator=nullptr)</td></tr>
<tr class="memdesc:ac885b6f537cb86c114be6696c3dc2fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update a buffer's data via an indirect copy from a temporary staging buffer. Updating memory via the use of a staging buffer is necessary when using memory without e_HOST_VISIBLE_BIT memory property flags meaning the buffer itself cannot be mapped to host memory. <a href="#ac885b6f537cb86c114be6696c3dc2fb6">More...</a><br/></td></tr>
<tr class="separator:ac885b6f537cb86c114be6696c3dc2fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">pvr::utils::updateHostVisibleBuffer</a> (pvrvk::Buffer &amp;buffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, bool flushMemory=false)</td></tr>
<tr class="memdesc:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update a buffer's data. This function maps and unmap the buffer only if the buffer is not already mapped. <a href="#a618e4160bd8c24d9e0d394dc9511f4a3">More...</a><br/></td></tr>
<tr class="separator:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cc4019e6c6315a8a714f4103bfe503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a71cc4019e6c6315a8a714f4103bfe503">pvr::utils::updateImage</a> (pvrvk::Device &amp;device, pvrvk::CommandBufferBase transferCommandBuffer, ImageUpdateInfo *updateInfos, uint32_t numUpdateInfos, pvrvk::Format format, pvrvk::ImageLayout layout, bool isCubeMap, pvrvk::Image &amp;image, vma::Allocator *bufferAllocator=nullptr)</td></tr>
<tr class="memdesc:a71cc4019e6c6315a8a714f4103bfe503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update an image's data. This function will record the update of the image in the supplied command buffer but NOT submit the command buffer, hence allowing the user to submit it at his own time. IMPORTANT. Assumes image layout is pvrvk::ImageLayout::e_DST_OPTIMAL IMPORTANT. The cleanup object that is the return value of the function must be kept alive as long until the moment that the relevant command buffer submission is finished. Then it can be destroyed (or the cleanup function be called) to free any relevant resources. <a href="#a71cc4019e6c6315a8a714f4103bfe503">More...</a><br/></td></tr>
<tr class="separator:a71cc4019e6c6315a8a714f4103bfe503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94564335e1a4bb4afe501e4b90c9c25e"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a94564335e1a4bb4afe501e4b90c9c25e">pvr::utils::uploadImage</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a94564335e1a4bb4afe501e4b90c9c25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a94564335e1a4bb4afe501e4b90c9c25e">More...</a><br/></td></tr>
<tr class="separator:a94564335e1a4bb4afe501e4b90c9c25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd6e8b8a62c678202323873aeda6115"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0bd6e8b8a62c678202323873aeda6115">pvr::utils::uploadImageAndView</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a0bd6e8b8a62c678202323873aeda6115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads an image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#a0bd6e8b8a62c678202323873aeda6115">More...</a><br/></td></tr>
<tr class="separator:a0bd6e8b8a62c678202323873aeda6115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabab7a3b0f9d671f39fd5d6cb9e5fad"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aaabab7a3b0f9d671f39fd5d6cb9e5fad">pvr::utils::uploadImageAndView</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:aaabab7a3b0f9d671f39fd5d6cb9e5fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. <a href="#aaabab7a3b0f9d671f39fd5d6cb9e5fad">More...</a><br/></td></tr>
<tr class="separator:aaabab7a3b0f9d671f39fd5d6cb9e5fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4275d35b8141132ad949ef9d8ad0f5a2"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4275d35b8141132ad949ef9d8ad0f5a2">pvr::utils::uploadImageAndViewSubmit</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandPool &amp;commandPool, pvrvk::Queue &amp;queue, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a4275d35b8141132ad949ef9d8ad0f5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads an image to GPU memory and returns the created image view and associated image. <a href="#a4275d35b8141132ad949ef9d8ad0f5a2">More...</a><br/></td></tr>
<tr class="separator:a4275d35b8141132ad949ef9d8ad0f5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains helper functions for several common complicated Vulkan tasks, such as swapchain creation and texture uploading. </p>
<dl class="section author"><dt>Author</dt><dd>PowerVR by Imagination, Developer Technology Team </dd></dl>
<dl class="section user"><dt>Copyright:</dt><dd>Copyright (c) Imagination Technologies Limited. </dd></dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
