<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRUtils: pvr::utils::vma::impl::Allocation_ Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li><li class="navelem"><b>vma</b></li><li class="navelem"><b>impl</b></li><li class="navelem"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html">Allocation_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils::vma::impl::Allocation_ Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_device_memory_wrapper__.html" title="A wrapper for device memory">DeviceMemoryWrapper_</a>. Class Just wraps the Vulkan device memory object allocated by the memory allocatpr. This class doesn't manages the creation and destruction of vulkan object. It only serves as the interface to device memory functions. 
 <a href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::utils::vma::impl::Allocation_:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation____inherit__graph.png" border="0" usemap="#pvr_1_1utils_1_1vma_1_1impl_1_1_allocation___inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1utils_1_1vma_1_1impl_1_1_allocation___inherit__map" id="pvr_1_1utils_1_1vma_1_1impl_1_1_allocation___inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f247284dc8f05963e45f4e8fec26d15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a2f247284dc8f05963e45f4e8fec26d15">canBecomeLost</a> () const </td></tr>
<tr class="memdesc:a2f247284dc8f05963e45f4e8fec26d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this allocation can become lost <a href="#a2f247284dc8f05963e45f4e8fec26d15">More...</a><br/></td></tr>
<tr class="separator:a2f247284dc8f05963e45f4e8fec26d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c85c8808871dd64c865ea4fe844903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a98c85c8808871dd64c865ea4fe844903">flushRange</a> (pvrvk::DeviceSize offset=0, pvrvk::DeviceSize size=VK_WHOLE_SIZE)</td></tr>
<tr class="memdesc:a98c85c8808871dd64c865ea4fe844903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush ranges of non-coherent memory from the host caches. <a href="#a98c85c8808871dd64c865ea4fe844903">More...</a><br/></td></tr>
<tr class="separator:a98c85c8808871dd64c865ea4fe844903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac845fea03f83cf9595c6eaff7ea97e60"><td class="memItemLeft" align="right" valign="top">AllocationCreateFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#ac845fea03f83cf9595c6eaff7ea97e60">getCreateFlags</a> () const </td></tr>
<tr class="memdesc:ac845fea03f83cf9595c6eaff7ea97e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this allocation create flags <a href="#ac845fea03f83cf9595c6eaff7ea97e60">More...</a><br/></td></tr>
<tr class="separator:ac845fea03f83cf9595c6eaff7ea97e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67297e9fbf78db84598147be76c59420"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a67297e9fbf78db84598147be76c59420">getMappedData</a> ()</td></tr>
<tr class="memdesc:a67297e9fbf78db84598147be76c59420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the beginning of this allocation as mapped data. <a href="#a67297e9fbf78db84598147be76c59420">More...</a><br/></td></tr>
<tr class="separator:a67297e9fbf78db84598147be76c59420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b5560d8afc49c09b25ba6b098f35b0"><td class="memItemLeft" align="right" valign="top">VkDeviceSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a43b5560d8afc49c09b25ba6b098f35b0">getMappedOffset</a> () const </td></tr>
<tr class="memdesc:a43b5560d8afc49c09b25ba6b098f35b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this mapped memory offset (const) <a href="#a43b5560d8afc49c09b25ba6b098f35b0">More...</a><br/></td></tr>
<tr class="separator:a43b5560d8afc49c09b25ba6b098f35b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32dd8abc1c5426776350af59636e8a9"><td class="memItemLeft" align="right" valign="top">VkDeviceSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#ab32dd8abc1c5426776350af59636e8a9">getMappedSize</a> () const </td></tr>
<tr class="memdesc:ab32dd8abc1c5426776350af59636e8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this mapped memory size (const) <a href="#ab32dd8abc1c5426776350af59636e8a9">More...</a><br/></td></tr>
<tr class="separator:ab32dd8abc1c5426776350af59636e8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2201ef774665dc7d0bca553a85647213"><td class="memItemLeft" align="right" valign="top">pvrvk::MemoryPropertyFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a2201ef774665dc7d0bca553a85647213">getMemoryFlags</a> () const </td></tr>
<tr class="memdesc:a2201ef774665dc7d0bca553a85647213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memory flags(const) <a href="#a2201ef774665dc7d0bca553a85647213">More...</a><br/></td></tr>
<tr class="separator:a2201ef774665dc7d0bca553a85647213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306845cc2750548f4a54467fc02fffcd"><td class="memItemLeft" align="right" valign="top">Pool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a306845cc2750548f4a54467fc02fffcd">getMemoryPool</a> ()</td></tr>
<tr class="memdesc:a306845cc2750548f4a54467fc02fffcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this memory pool <a href="#a306845cc2750548f4a54467fc02fffcd">More...</a><br/></td></tr>
<tr class="separator:a306845cc2750548f4a54467fc02fffcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4189f708611a8b7ef7939f3f10d1274"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#ae4189f708611a8b7ef7939f3f10d1274">getMemoryType</a> () const </td></tr>
<tr class="memdesc:ae4189f708611a8b7ef7939f3f10d1274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memory type <a href="#ae4189f708611a8b7ef7939f3f10d1274">More...</a><br/></td></tr>
<tr class="separator:ae4189f708611a8b7ef7939f3f10d1274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1922af92588e2d78e67358b76bce5877"><td class="memItemLeft" align="right" valign="top">pvrvk::DeviceSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a1922af92588e2d78e67358b76bce5877">getOffset</a> () const </td></tr>
<tr class="memdesc:a1922af92588e2d78e67358b76bce5877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offset into deviceMemory object to the beginning of this allocation, in bytes. (deviceMemory, offset) pair is unique to this allocation. <a href="#a1922af92588e2d78e67358b76bce5877">More...</a><br/></td></tr>
<tr class="separator:a1922af92588e2d78e67358b76bce5877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a16c5b579016fae91995e69970612b"><td class="memItemLeft" align="right" valign="top">VkDeviceSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a03a16c5b579016fae91995e69970612b">getSize</a> () const </td></tr>
<tr class="memdesc:a03a16c5b579016fae91995e69970612b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this memory size (const) <a href="#a03a16c5b579016fae91995e69970612b">More...</a><br/></td></tr>
<tr class="separator:a03a16c5b579016fae91995e69970612b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a23cdbefd65312a1c6723a454392fe"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#ac2a23cdbefd65312a1c6723a454392fe">getUserData</a> ()</td></tr>
<tr class="memdesc:ac2a23cdbefd65312a1c6723a454392fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the user data <a href="#ac2a23cdbefd65312a1c6723a454392fe">More...</a><br/></td></tr>
<tr class="separator:ac2a23cdbefd65312a1c6723a454392fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a2a2a6d20d9b454ed8026b89a02399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a71a2a2a6d20d9b454ed8026b89a02399">invalidateRange</a> (VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE)</td></tr>
<tr class="memdesc:a71a2a2a6d20d9b454ed8026b89a02399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates ranges of non-coherent memory from the host caches. <a href="#a71a2a2a6d20d9b454ed8026b89a02399">More...</a><br/></td></tr>
<tr class="separator:a71a2a2a6d20d9b454ed8026b89a02399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20572f998ec1b2b31983559f99ea3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a6c20572f998ec1b2b31983559f99ea3f">isAllocationLost</a> () const </td></tr>
<tr class="memdesc:a6c20572f998ec1b2b31983559f99ea3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this allocation is lost. Allocation created with AllocationCreateFlags::e_CAN_BECOME_LOST_BIT flag can become lost as a result of another allocation with AllocationCreateFlags::e_CAN_MAKE_OTHER_LOST_BIT flag, so you must check it before use <a href="#a6c20572f998ec1b2b31983559f99ea3f">More...</a><br/></td></tr>
<tr class="separator:a6c20572f998ec1b2b31983559f99ea3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2e4c3016cb7725520093ad4bcf733a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a3b2e4c3016cb7725520093ad4bcf733a">isMappable</a> () const </td></tr>
<tr class="memdesc:a3b2e4c3016cb7725520093ad4bcf733a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this memory block is mappable by the host (const). <a href="#a3b2e4c3016cb7725520093ad4bcf733a">More...</a><br/></td></tr>
<tr class="separator:a3b2e4c3016cb7725520093ad4bcf733a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68b061cd358337b6fb266aae88d6f70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#af68b061cd358337b6fb266aae88d6f70">isMapped</a> () const </td></tr>
<tr class="memdesc:af68b061cd358337b6fb266aae88d6f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this memory is being mapped by the host (const) <a href="#af68b061cd358337b6fb266aae88d6f70">More...</a><br/></td></tr>
<tr class="separator:af68b061cd358337b6fb266aae88d6f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add681936918645046df692d853d788bf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#add681936918645046df692d853d788bf">map</a> (VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, pvrvk::MemoryMapFlags memoryMapFlags=pvrvk::MemoryMapFlags::e_NONE)</td></tr>
<tr class="memdesc:add681936918645046df692d853d788bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the memory allocation. Also you can directly call map on the device memory on you own if you want But using this function makes sures correct offset and size is always specified. Therefore map and unmap of this object is recommended. Do not use it on memory allocated with AllocationCreateFlags::e_PERSISTENT_MAP_BIT as multiple maps to same DeviceMemory is illegal. <a href="#add681936918645046df692d853d788bf">More...</a><br/></td></tr>
<tr class="separator:add681936918645046df692d853d788bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c00e0dd4e66d36af843dcc02fed5590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#a1c00e0dd4e66d36af843dcc02fed5590">setUserData</a> (void *userData)</td></tr>
<tr class="memdesc:a1c00e0dd4e66d36af843dcc02fed5590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets userData of this allocation to new value. <a href="#a1c00e0dd4e66d36af843dcc02fed5590">More...</a><br/></td></tr>
<tr class="separator:a1c00e0dd4e66d36af843dcc02fed5590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf908ca7ff1a9566b2cfaede45ea5fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_allocation__.html#adf908ca7ff1a9566b2cfaede45ea5fdd">unmap</a> ()</td></tr>
<tr class="memdesc:adf908ca7ff1a9566b2cfaede45ea5fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function unmaps the memory previously mapped by the mapMemory function <a href="#adf908ca7ff1a9566b2cfaede45ea5fdd">More...</a><br/></td></tr>
<tr class="separator:adf908ca7ff1a9566b2cfaede45ea5fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classpvr_1_1utils_1_1vma_1_1impl_1_1_device_memory_wrapper__.html" title="A wrapper for device memory">DeviceMemoryWrapper_</a>. Class Just wraps the Vulkan device memory object allocated by the memory allocatpr. This class doesn't manages the creation and destruction of vulkan object. It only serves as the interface to device memory functions.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2f247284dc8f05963e45f4e8fec26d15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::vma::impl::Allocation_::canBecomeLost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this allocation can become lost</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this allocation can become lost</dd></dl>

</div>
</div>
<a class="anchor" id="a98c85c8808871dd64c865ea4fe844903"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::vma::impl::Allocation_::flushRange </td>
          <td>(</td>
          <td class="paramtype">pvrvk::DeviceSize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::DeviceSize&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush ranges of non-coherent memory from the host caches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset into the device memory to map</td></tr>
    <tr><td class="paramname">size</td><td>The size of the returned mapped data</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac845fea03f83cf9595c6eaff7ea97e60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AllocationCreateFlags pvr::utils::vma::impl::Allocation_::getCreateFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get this allocation create flags</p>
<dl class="section return"><dt>Returns</dt><dd>The allocation creation flags.</dd></dl>

</div>
</div>
<a class="anchor" id="a67297e9fbf78db84598147be76c59420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pvr::utils::vma::impl::Allocation_::getMappedData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the beginning of this allocation as mapped data.</p>
<p>Null if this allocation is not persistently mapped. It can change after call to unmapPersistentlyMappedMemory(), mapPersistentlyMappedMemory() from the memory allocator. Also it can change after call to defragment() if this allocation is passed to the function. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the mapped data</dd></dl>

</div>
</div>
<a class="anchor" id="a43b5560d8afc49c09b25ba6b098f35b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkDeviceSize pvr::utils::vma::impl::Allocation_::getMappedOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this mapped memory offset (const)</p>
<dl class="section return"><dt>Returns</dt><dd>The offset into the device memory which has been mapped</dd></dl>

</div>
</div>
<a class="anchor" id="ab32dd8abc1c5426776350af59636e8a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkDeviceSize pvr::utils::vma::impl::Allocation_::getMappedSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this mapped memory size (const)</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the mapped memory</dd></dl>

</div>
</div>
<a class="anchor" id="a2201ef774665dc7d0bca553a85647213"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::MemoryPropertyFlags pvr::utils::vma::impl::Allocation_::getMemoryFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the memory flags(const)</p>
<dl class="section return"><dt>Returns</dt><dd>pvrvk::MemoryPropertyFlags</dd></dl>

</div>
</div>
<a class="anchor" id="a306845cc2750548f4a54467fc02fffcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Pool pvr::utils::vma::impl::Allocation_::getMemoryPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this memory pool</p>
<dl class="section return"><dt>Returns</dt><dd>The memory pool</dd></dl>

</div>
</div>
<a class="anchor" id="ae4189f708611a8b7ef7939f3f10d1274"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::utils::vma::impl::Allocation_::getMemoryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the memory type</p>
<dl class="section return"><dt>Returns</dt><dd>The memory type of the pvrvk::Allocation</dd></dl>

</div>
</div>
<a class="anchor" id="a1922af92588e2d78e67358b76bce5877"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::DeviceSize pvr::utils::vma::impl::Allocation_::getOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get offset into deviceMemory object to the beginning of this allocation, in bytes. (deviceMemory, offset) pair is unique to this allocation.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns device offset</dd></dl>

</div>
</div>
<a class="anchor" id="a03a16c5b579016fae91995e69970612b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkDeviceSize pvr::utils::vma::impl::Allocation_::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this memory size (const)</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the device memory</dd></dl>

</div>
</div>
<a class="anchor" id="ac2a23cdbefd65312a1c6723a454392fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * pvr::utils::vma::impl::Allocation_::getUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the user data</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the user data</dd></dl>

</div>
</div>
<a class="anchor" id="a71a2a2a6d20d9b454ed8026b89a02399"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::vma::impl::Allocation_::invalidateRange </td>
          <td>(</td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates ranges of non-coherent memory from the host caches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset into the device memory to map</td></tr>
    <tr><td class="paramname">size</td><td>The size of the returned mapped data</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c20572f998ec1b2b31983559f99ea3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::vma::impl::Allocation_::isAllocationLost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this allocation is lost. Allocation created with AllocationCreateFlags::e_CAN_BECOME_LOST_BIT flag can become lost as a result of another allocation with AllocationCreateFlags::e_CAN_MAKE_OTHER_LOST_BIT flag, so you must check it before use</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the allocation is lost.</dd></dl>

</div>
</div>
<a class="anchor" id="a3b2e4c3016cb7725520093ad4bcf733a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::vma::impl::Allocation_::isMappable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this memory block is mappable by the host (const).</p>
<dl class="section return"><dt>Returns</dt><dd>True is this memory block can be mapped, otherwise false.</dd></dl>

</div>
</div>
<a class="anchor" id="af68b061cd358337b6fb266aae88d6f70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::vma::impl::Allocation_::isMapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this memory is being mapped by the host (const)</p>
<dl class="section return"><dt>Returns</dt><dd>VkDeviceSize&lt;/returns </dd></dl>

</div>
</div>
<a class="anchor" id="add681936918645046df692d853d788bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pvr::utils::vma::impl::Allocation_::map </td>
          <td>(</td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryMapFlags&#160;</td>
          <td class="paramname"><em>memoryMapFlags</em> = <code>pvrvk::MemoryMapFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the memory allocation. Also you can directly call map on the device memory on you own if you want But using this function makes sures correct offset and size is always specified. Therefore map and unmap of this object is recommended. Do not use it on memory allocated with AllocationCreateFlags::e_PERSISTENT_MAP_BIT as multiple maps to same DeviceMemory is illegal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset into the device memory to map</td></tr>
    <tr><td class="paramname">size</td><td>The size of the returned mapped data</td></tr>
    <tr><td class="paramname">memoryMapFlags</td><td>Memory mapping flags specifying how the mappng will take place</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returned mapped data</dd></dl>

</div>
</div>
<a class="anchor" id="a1c00e0dd4e66d36af843dcc02fed5590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::vma::impl::Allocation_::setUserData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets userData of this allocation to new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>The new data to srt</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf908ca7ff1a9566b2cfaede45ea5fdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::vma::impl::Allocation_::unmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function unmaps the memory previously mapped by the mapMemory function</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRUtils/Vulkan/<a class="el" href="_memory_allocator_8h_source.html">MemoryAllocator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
