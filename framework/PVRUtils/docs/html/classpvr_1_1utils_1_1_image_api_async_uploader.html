<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.6"/>
<title>PVRUtils: pvr::utils::ImageApiAsyncUploader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="classpvr_1_1utils_1_1_image_api_async_uploader.html">ImageApiAsyncUploader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1utils_1_1_image_api_async_uploader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils::ImageApiAsyncUploader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class wraps a worker thread that uploads texture to the GPU asynchronously and returns futures to them. This class would normally be used with Texture Futures as well, in order to do both of the operations asynchronously. 
 <a href="classpvr_1_1utils_1_1_image_api_async_uploader.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::utils::ImageApiAsyncUploader:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1utils_1_1_image_api_async_uploader__inherit__graph.png" border="0" usemap="#pvr_1_1utils_1_1_image_api_async_uploader_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1utils_1_1_image_api_async_uploader_inherit__map" id="pvr_1_1utils_1_1_image_api_async_uploader_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a42378e7f429b0ecc22ad6cf94510c022"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
async::IFrameworkAsyncResult<br class="typebreak"/>
&lt; pvrvk::ImageView &gt;::Callback&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_image_api_async_uploader.html#a42378e7f429b0ecc22ad6cf94510c022">CallbackType</a></td></tr>
<tr class="memdesc:a42378e7f429b0ecc22ad6cf94510c022"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the optional callback that is called at the end of the operation <a href="#a42378e7f429b0ecc22ad6cf94510c022">More...</a><br/></td></tr>
<tr class="separator:a42378e7f429b0ecc22ad6cf94510c022"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af6bd438c42f6205b82793948110d3911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_image_api_async_uploader.html#af6bd438c42f6205b82793948110d3911">init</a> (pvrvk::Device &amp;device, pvrvk::Queue &amp;queue, async::Mutex *queueSemaphore=nullptr)</td></tr>
<tr class="memdesc:af6bd438c42f6205b82793948110d3911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize this AsyncUploader. Do not use the queue and pool unguarded aftewards, as they will be accessed from an indeterminate thread at indeterminate times. It is ideal that the queue is only used by this Uploader, but if it is not, a (CPU) Semaphore must be passed to guard access to the queue. <a href="#af6bd438c42f6205b82793948110d3911">More...</a><br/></td></tr>
<tr class="separator:af6bd438c42f6205b82793948110d3911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59b87478ce58a1ae71a4f22c92dfb22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr_1_1utils.html#a990a2454c0ddfb8bf5383a11262a76ec">AsyncApiTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_image_api_async_uploader.html#ab59b87478ce58a1ae71a4f22c92dfb22">uploadTextureAsync</a> (const <a class="el" href="namespacepvr_1_1utils.html#a54bd78a7c682d6b8161db1db04f1f910">AsyncTexture</a> &amp;texture, bool allowDecompress=true, <a class="el" href="classpvr_1_1utils_1_1_image_api_async_uploader.html#a42378e7f429b0ecc22ad6cf94510c022">CallbackType</a> callback=nullptr, bool callbackBeforeSignal=false)</td></tr>
<tr class="memdesc:ab59b87478ce58a1ae71a4f22c92dfb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin a texture uploading task and return the future to the Vulkan Texture. Use the returned future to query completion and get the result. Takes asynchronous textures as input so that the loading and uploading tasks can be chained and done on different threads. <a href="#ab59b87478ce58a1ae71a4f22c92dfb22">More...</a><br/></td></tr>
<tr class="separator:ab59b87478ce58a1ae71a4f22c92dfb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class wraps a worker thread that uploads texture to the GPU asynchronously and returns futures to them. This class would normally be used with Texture Futures as well, in order to do both of the operations asynchronously.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a42378e7f429b0ecc22ad6cf94510c022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef async::IFrameworkAsyncResult&lt;pvrvk::ImageView&gt;::Callback <a class="el" href="classpvr_1_1utils_1_1_image_api_async_uploader.html#a42378e7f429b0ecc22ad6cf94510c022">pvr::utils::ImageApiAsyncUploader::CallbackType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the optional callback that is called at the end of the operation</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af6bd438c42f6205b82793948110d3911"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::ImageApiAsyncUploader::init </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">async::Mutex *&#160;</td>
          <td class="paramname"><em>queueSemaphore</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize this AsyncUploader. Do not use the queue and pool unguarded aftewards, as they will be accessed from an indeterminate thread at indeterminate times. It is ideal that the queue is only used by this Uploader, but if it is not, a (CPU) Semaphore must be passed to guard access to the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A Vulkan _device that will be used to create the textures. A Command pool will be created on this device for the queue family of the queue</td></tr>
    <tr><td class="paramname">queue</td><td>A Vulkan command queue that will be used to upload the textures</td></tr>
    <tr><td class="paramname">queueSemaphore</td><td>Use the Semaphore as a mutex: Initial count 1, call wait() before all accesses to the Vulkan queue, then signal() when finished accessing. If the queue does not need external synchronization (i.e. it is only used by this object), leave the queueSemaphore at its default value of NULL</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab59b87478ce58a1ae71a4f22c92dfb22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr_1_1utils.html#a990a2454c0ddfb8bf5383a11262a76ec">AsyncApiTexture</a> pvr::utils::ImageApiAsyncUploader::uploadTextureAsync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1utils.html#a54bd78a7c682d6b8161db1db04f1f910">AsyncTexture</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1utils_1_1_image_api_async_uploader.html#a42378e7f429b0ecc22ad6cf94510c022">CallbackType</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>callbackBeforeSignal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin a texture uploading task and return the future to the Vulkan Texture. Use the returned future to query completion and get the result. Takes asynchronous textures as input so that the loading and uploading tasks can be chained and done on different threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>A PVR Texture future (can be gotten from the Async Texture Loader or another async source)</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>If the texture is compressed to an unsupported format, allow it to be decompressed to RGBA8 if a software decompressor is available. Default true</td></tr>
    <tr><td class="paramname">callback</td><td>An optional function pointer that will be invoked when the uploading is complete. IF you use the callback AND the you set the flag "callbackBeforeSignal" to TRUE, do NOT call the "get" function of the future in the callback. Default NULL.</td></tr>
    <tr><td class="paramname">callbackBeforeSignal</td><td>A flag signifying if the callback should be called BEFORE or AFTER the semaphore of the Result future (the Texture future) is signalled as complete. Defaults to false, so as to avoid the deadlock that will happen if the user attempts to call "get" on the future while the signal will happen just after return of the callback. Set to "true" if you want to do something WITHOUT calling "get" on the future, but before the texture is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A texture upload Future which you can use to query or get the uploaded texture</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRUtils/Vulkan/<a class="el" href="_asynchronous_vk_8h_source.html">AsynchronousVk.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
