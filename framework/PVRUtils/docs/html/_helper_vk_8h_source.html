<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.13"/>
<title>PVRUtils: /usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRUtils/Vulkan/HelperVk.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ca6309d378ceffb9970caf11a0592736.html">SDK</a></li><li class="navelem"><a class="el" href="dir_1b17efea2d0d450cd18d875f7f2a6e9c.html">framework</a></li><li class="navelem"><a class="el" href="dir_04d546e47904494c8f2a634ed861a0d7.html">PVRUtils</a></li><li class="navelem"><a class="el" href="dir_f07b109ccd199f39a4dc7ead82937581.html">Vulkan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">HelperVk.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_helper_vk_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#pragma once</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#include &quot;PVRCore/PVRCore.h&quot;</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &quot;PVRCore/stream/FileStream.h&quot;</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &quot;PVRAssets/Model.h&quot;</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &quot;PVRAssets/PVRAssets.h&quot;</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#include &quot;PVRCore/texture/TextureLoad.h&quot;</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#include &quot;PVRVk/DeviceVk.h&quot;</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &quot;PVRVk/PhysicalDeviceVk.h&quot;</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &quot;PVRVk/InstanceVk.h&quot;</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#include &quot;PVRVk/CommandBufferVk.h&quot;</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#include &quot;PVRVk/ImageVk.h&quot;</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &quot;PVRVk/SurfaceVk.h&quot;</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="_convert_to_p_v_r_vk_types_8h.html">ConvertToPVRVkTypes.h</a>&quot;</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;PVRVk/CommandPoolVk.h&quot;</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;PVRVk/QueueVk.h&quot;</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;PVRVk/RenderPassVk.h&quot;</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;PVRVk/FramebufferVk.h&quot;</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;PVRVk/SwapchainVk.h&quot;</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="_memory_allocator_8h.html">PVRUtils/Vulkan/MemoryAllocator.h</a>&quot;</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="_multi_object_8h.html">PVRUtils/MultiObject.h</a>&quot;</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacepvr.html">pvr</a> {</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="keyword">namespace </span>utils {</div><div class="line"><a name="l00034"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a7b2d4df80d31e3e63923ab1d68152ace">   34</a></span>&#160;<span class="keyword">inline</span> uint8_t <a class="code" href="namespacepvr_1_1utils.html#a7b2d4df80d31e3e63923ab1d68152ace">getNumSamplesFromSampleCountFlags</a>(pvrvk::SampleCountFlags sampleCountFlags)</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;{</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    uint8_t numSamples = 0;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <span class="keywordflow">if</span> (static_cast&lt;uint32_t&gt;(sampleCountFlags &amp; pvrvk::SampleCountFlags::e_1_BIT) != 0) { numSamples += 1; }</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="keywordflow">if</span> (static_cast&lt;uint32_t&gt;(sampleCountFlags &amp; pvrvk::SampleCountFlags::e_2_BIT) != 0) { numSamples += 2; }</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="keywordflow">if</span> (static_cast&lt;uint32_t&gt;(sampleCountFlags &amp; pvrvk::SampleCountFlags::e_4_BIT) != 0) { numSamples += 4; }</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="keywordflow">if</span> (static_cast&lt;uint32_t&gt;(sampleCountFlags &amp; pvrvk::SampleCountFlags::e_8_BIT) != 0) { numSamples += 8; }</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">if</span> (static_cast&lt;uint32_t&gt;(sampleCountFlags &amp; pvrvk::SampleCountFlags::e_16_BIT) != 0) { numSamples += 16; }</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordflow">if</span> (static_cast&lt;uint32_t&gt;(sampleCountFlags &amp; pvrvk::SampleCountFlags::e_32_BIT) != 0) { numSamples += 32; }</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="keywordflow">if</span> (static_cast&lt;uint32_t&gt;(sampleCountFlags &amp; pvrvk::SampleCountFlags::e_64_BIT) != 0) { numSamples += 64; }</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordflow">return</span> numSamples;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;pvrvk::ImageAspectFlags <a class="code" href="namespacepvr_1_1utils.html#a93735fa36d5aedc03cf746dfa208a4b5">inferAspectFromFormat</a>(pvrvk::Format format);</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a56ce1f5bcf625224715988176c3519a2">getColorBits</a>(pvrvk::Format format, uint32_t&amp; redBits, uint32_t&amp; greenBits, uint32_t&amp; blueBits, uint32_t&amp; alphaBits);</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a1bcac1e9af1869244329d12c291200a5">getDepthStencilBits</a>(pvrvk::Format format, uint32_t&amp; depthBits, uint32_t&amp; stencilBits);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">   69</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">DebugUtilsCallbacks</a></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;{</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00073"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html#aeb1f89203f5e3397200ff8b491810dea">   73</a></span>&#160;    pvrvk::DebugUtilsMessenger <a class="code" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html#aeb1f89203f5e3397200ff8b491810dea">debugUtilsMessengers</a>[2];</div><div class="line"><a name="l00075"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html#a9e94e7d45269071a64d86419c18df205">   75</a></span>&#160;    pvrvk::DebugReportCallback <a class="code" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html#a9e94e7d45269071a64d86419c18df205">debugCallbacks</a>[2];</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;};</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<a class="code" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">DebugUtilsCallbacks</a> <a class="code" href="namespacepvr_1_1utils.html#a3c7a82ad08f5f77c574a75fc1c4eca9a">createDebugUtilsCallbacks</a>(pvrvk::Instance&amp; instance);</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a7eaec27096b06e097a3ead372e30c68c">   89</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a7eaec27096b06e097a3ead372e30c68c">beginQueueDebugLabel</a>(pvrvk::Queue queue, <span class="keyword">const</span> pvrvk::DebugUtilsLabel&amp; labelInfo)</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;{</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="comment">// if the VK_EXT_debug_utils extension is supported then start the queue label region</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="keywordflow">if</span> (queue-&gt;getDevice()-&gt;getPhysicalDevice()-&gt;getInstance()-&gt;getEnabledExtensionTable().extDebugUtilsEnabled) { queue-&gt;beginDebugUtilsLabel(labelInfo); }</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;}</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a605300322093e44b7cd509533f14b4fa">   97</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a605300322093e44b7cd509533f14b4fa">endQueueDebugLabel</a>(pvrvk::Queue queue)</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;{</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="comment">// if the VK_EXT_debug_utils extension is supported then end the queue label region</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keywordflow">if</span> (queue-&gt;getDevice()-&gt;getPhysicalDevice()-&gt;getInstance()-&gt;getEnabledExtensionTable().extDebugUtilsEnabled) { queue-&gt;endDebugUtilsLabel(); }</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;}</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">  107</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">beginCommandBufferDebugLabel</a>(pvrvk::CommandBufferBase commandBufferBase, <span class="keyword">const</span> pvrvk::DebugUtilsLabel&amp; labelInfo)</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;{</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="comment">// if the VK_EXT_debug_utils extension is supported then start the queue label region</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordflow">if</span> (commandBufferBase-&gt;getDevice()-&gt;getPhysicalDevice()-&gt;getInstance()-&gt;getEnabledExtensionTable().extDebugUtilsEnabled) { commandBufferBase-&gt;beginDebugUtilsLabel(labelInfo); }</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="comment">// else if the VK_EXT_debug_marker extension is supported then start the debug marker region</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (commandBufferBase-&gt;getDevice()-&gt;getEnabledExtensionTable().extDebugMarkerEnabled)</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        pvrvk::DebugMarkerMarkerInfo markerInfo(labelInfo.getLabelName(), labelInfo.getR(), labelInfo.getG(), labelInfo.getB(), labelInfo.getA());</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        commandBufferBase-&gt;debugMarkerBeginEXT(markerInfo);</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;    }</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;}</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">  121</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">endCommandBufferDebugLabel</a>(pvrvk::CommandBufferBase commandBufferBase)</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;{</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    <span class="comment">// if the VK_EXT_debug_utils extension is supported then end the command buffer label region</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="keywordflow">if</span> (commandBufferBase-&gt;getDevice()-&gt;getPhysicalDevice()-&gt;getInstance()-&gt;getEnabledExtensionTable().extDebugUtilsEnabled) { commandBufferBase-&gt;endDebugUtilsLabel(); }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="comment">// else if the VK_EXT_debug_marker extension is supported then end the debug marker region</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (commandBufferBase-&gt;getDevice()-&gt;getEnabledExtensionTable().extDebugMarkerEnabled)</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        commandBufferBase-&gt;debugMarkerEndEXT();</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    }</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;}</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">  135</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">insertDebugUtilsLabel</a>(pvrvk::CommandBufferBase commandBufferBase, <span class="keyword">const</span> pvrvk::DebugUtilsLabel&amp; labelInfo)</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;{</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="comment">// if the VK_EXT_debug_utils extension is supported then insert the queue label region</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">if</span> (commandBufferBase-&gt;getDevice()-&gt;getPhysicalDevice()-&gt;getInstance()-&gt;getEnabledExtensionTable().extDebugUtilsEnabled)</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    { commandBufferBase-&gt;insertDebugUtilsLabel(labelInfo); } <span class="comment">// else if the VK_EXT_debug_marker extension is supported then insert the debug marker</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (commandBufferBase-&gt;getDevice()-&gt;getEnabledExtensionTable().extDebugMarkerEnabled)</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    {</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        pvrvk::DebugMarkerMarkerInfo markerInfo(labelInfo.getLabelName(), labelInfo.getR(), labelInfo.getG(), labelInfo.getB(), labelInfo.getA());</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        commandBufferBase-&gt;debugMarkerInsertEXT(markerInfo);</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;}</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#ab62f121a7b8a9d790ca4e4e3dfcff0aa">  151</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">beginCommandBufferDebugLabel</a>(pvrvk::CommandBuffer&amp; commandBuffer, <span class="keyword">const</span> pvrvk::DebugUtilsLabel&amp; labelInfo)</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;{</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">beginCommandBufferDebugLabel</a>(static_cast&lt;pvrvk::CommandBufferBase&gt;(commandBuffer), labelInfo);</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;}</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a45dc67a22e33dc6bf735edc27a1432ef">  160</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">beginCommandBufferDebugLabel</a>(pvrvk::SecondaryCommandBuffer&amp; secondaryCommandBuffer, <span class="keyword">const</span> pvrvk::DebugUtilsLabel&amp; labelInfo)</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;{</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">beginCommandBufferDebugLabel</a>(static_cast&lt;pvrvk::CommandBufferBase&gt;(secondaryCommandBuffer), labelInfo);</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;}</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a2da693f264b2b719a77fc84bf0a32ec5">  167</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">endCommandBufferDebugLabel</a>(pvrvk::CommandBuffer&amp; commandBuffer) { <a class="code" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">endCommandBufferDebugLabel</a>(static_cast&lt;pvrvk::CommandBufferBase&gt;(commandBuffer)); }</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#adee1c88c7937b7a16127e810b75b2ab7">  171</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">endCommandBufferDebugLabel</a>(pvrvk::SecondaryCommandBuffer&amp; secondaryCommandBuffer)</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;{</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">endCommandBufferDebugLabel</a>(static_cast&lt;pvrvk::CommandBufferBase&gt;(secondaryCommandBuffer));</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;}</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#ab77d5528ee9f9dc1f4dda381175b89eb">  179</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">insertDebugUtilsLabel</a>(pvrvk::CommandBuffer&amp; commandBuffer, <span class="keyword">const</span> pvrvk::DebugUtilsLabel&amp; labelInfo)</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;{</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">insertDebugUtilsLabel</a>(static_cast&lt;pvrvk::CommandBufferBase&gt;(commandBuffer), labelInfo);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;}</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a2938b3543ae68e23f0f2eb348a786ae9">  187</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">insertDebugUtilsLabel</a>(pvrvk::SecondaryCommandBuffer&amp; secondaryCommandBuffer, <span class="keyword">const</span> pvrvk::DebugUtilsLabel&amp; labelInfo)</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;{</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">insertDebugUtilsLabel</a>(static_cast&lt;pvrvk::CommandBufferBase&gt;(secondaryCommandBuffer), labelInfo);</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;}</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;pvrvk::Buffer <a class="code" href="namespacepvr_1_1utils.html#a1e975fe49bd5070e883c7b34f1b55cf5">createBuffer</a>(pvrvk::Device device, <span class="keyword">const</span> pvrvk::BufferCreateInfo&amp; createInfo, pvrvk::MemoryPropertyFlags requiredMemoryFlags,</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    pvrvk::MemoryPropertyFlags optimalMemoryFlags = pvrvk::MemoryPropertyFlags::e_NONE, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags = vma::AllocationCreateFlags::e_MAPPED_BIT);</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a> <a class="code" href="namespacepvr_1_1utils.html#a5503c76488af3bca91058f4daa58ecfe">createImage</a>(pvrvk::Device device, <span class="keyword">const</span> pvrvk::ImageCreateInfo&amp; createInfo,</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    pvrvk::MemoryPropertyFlags requiredMemoryFlags = pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT, pvrvk::MemoryPropertyFlags optimalMemoryFlags = pvrvk::MemoryPropertyFlags::e_NONE,</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a3555f264beaaf83ff1b84853a87a40fe">  234</a></span>&#160;<span class="keyword">inline</span> glm::mat4 <a class="code" href="namespacepvr_1_1utils.html#a3555f264beaaf83ff1b84853a87a40fe">getPerspectiveMatrix</a>(<span class="keywordtype">float</span> fovy, <span class="keywordtype">float</span> aspect, <span class="keywordtype">float</span> near1, <span class="keywordtype">float</span> far1, <span class="keywordtype">float</span> rotate = .0f)</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;{</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    glm::mat4 mat = glm::perspective(fovy, aspect, near1, far1);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    mat[1][1] *= -1.f; <span class="comment">// negate the y axis&#39;s y component, because vulkan coordinate system is +y down</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="keywordflow">return</span> (rotate == 0.f ? mat : glm::rotate(rotate, glm::vec3(0.0f, 0.0f, 1.0f)) * mat);</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;}</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a19f7af5558e7afc812edc1e8899d8f50">setImageLayoutAndQueueFamilyOwnership</a>(pvrvk::CommandBufferBase srccmd, pvrvk::CommandBufferBase dstcmd, uint32_t srcQueueFamily, uint32_t dstQueueFamily,</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, <a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a>&amp; image, uint32_t baseMipLevel, uint32_t numMipLevels, uint32_t baseArrayLayer, uint32_t numArrayLayers,</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    pvrvk::ImageAspectFlags aspect);</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00263"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a076fe31eafd575f7f2a10f27f6130935">  263</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a076fe31eafd575f7f2a10f27f6130935">setImageLayout</a>(<a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a>&amp; image, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::CommandBufferBase transitionCmdBuffer)</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;{</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a19f7af5558e7afc812edc1e8899d8f50">setImageLayoutAndQueueFamilyOwnership</a>(transitionCmdBuffer, pvrvk::CommandBufferBase(), static_cast&lt;uint32_t&gt;(-1), static_cast&lt;uint32_t&gt;(-1), oldLayout, newLayout, image, 0,</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        image-&gt;getNumMipLevels(), 0, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(image-&gt;getNumArrayLayers()), <a class="code" href="namespacepvr_1_1utils.html#a93735fa36d5aedc03cf746dfa208a4b5">inferAspectFromFormat</a>(image-&gt;getFormat()));</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;}</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;pvrvk::ImageView <a class="code" href="namespacepvr_1_1utils.html#a4275d35b8141132ad949ef9d8ad0f5a2">uploadImageAndViewSubmit</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> Texture&amp; texture, <span class="keywordtype">bool</span> allowDecompress, pvrvk::CommandPool&amp; commandPool, pvrvk::Queue&amp; queue,</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    pvrvk::ImageUsageFlags usageFlags = pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout = pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL,</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* stagingBufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;pvrvk::ImageView <a class="code" href="namespacepvr_1_1utils.html#a0bd6e8b8a62c678202323873aeda6115">uploadImageAndView</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> Texture&amp; texture, <span class="keywordtype">bool</span> allowDecompress, pvrvk::SecondaryCommandBuffer&amp; commandBuffer,</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    pvrvk::ImageUsageFlags usageFlags = pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout = pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL,</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* stagingBufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;pvrvk::ImageView <a class="code" href="namespacepvr_1_1utils.html#a0bd6e8b8a62c678202323873aeda6115">uploadImageAndView</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> Texture&amp; texture, <span class="keywordtype">bool</span> allowDecompress, pvrvk::CommandBuffer&amp; commandBuffer,</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    pvrvk::ImageUsageFlags usageFlags = pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout = pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL,</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* stagingBufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a> <a class="code" href="namespacepvr_1_1utils.html#a94564335e1a4bb4afe501e4b90c9c25e">uploadImage</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> Texture&amp; texture, <span class="keywordtype">bool</span> allowDecompress, pvrvk::CommandBuffer&amp; commandBuffer,</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    pvrvk::ImageUsageFlags usageFlags = pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout = pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL,</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* stagingBufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;pvrvk::ImageView <a class="code" href="namespacepvr_1_1utils.html#ad7010e7802edc5e1cc101034ac386d37">loadAndUploadImageAndView</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> <span class="keywordtype">char</span>* fileName, <span class="keywordtype">bool</span> allowDecompress, pvrvk::CommandBuffer&amp; commandBuffer, IAssetProvider&amp; assetProvider,</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    pvrvk::ImageUsageFlags usageFlags = pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout = pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL,</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    Texture* outAssetTexture = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* stagingBufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a> <a class="code" href="namespacepvr_1_1utils.html#a9bf319f2a39bf8149f2c8c4b36b1382a">loadAndUploadImage</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> <span class="keywordtype">char</span>* fileName, <span class="keywordtype">bool</span> allowDecompress, pvrvk::CommandBuffer&amp; commandBuffer, IAssetProvider&amp; assetProvider,</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    pvrvk::ImageUsageFlags usageFlags = pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout = pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL,</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    Texture* outAssetTexture = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* stagingBufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a> <a class="code" href="namespacepvr_1_1utils.html#a9bf319f2a39bf8149f2c8c4b36b1382a">loadAndUploadImage</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> std::string&amp; fileName, <span class="keywordtype">bool</span> allowDecompress, pvrvk::CommandBuffer&amp; commandBuffer, IAssetProvider&amp; assetProvider,</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    pvrvk::ImageUsageFlags usageFlags = pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout = pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL,</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    Texture* outAssetTexture = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* stagingBufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;pvrvk::ImageView <a class="code" href="namespacepvr_1_1utils.html#ad7010e7802edc5e1cc101034ac386d37">loadAndUploadImageAndView</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> <span class="keywordtype">char</span>* fileName, <span class="keywordtype">bool</span> allowDecompress, pvrvk::SecondaryCommandBuffer&amp; commandBuffer,</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    IAssetProvider&amp; assetProvider, pvrvk::ImageUsageFlags usageFlags = pvrvk::ImageUsageFlags::e_SAMPLED_BIT,</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    pvrvk::ImageLayout finalLayout = pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture* outAssetTexture = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* stagingBufferAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a> <a class="code" href="namespacepvr_1_1utils.html#a9bf319f2a39bf8149f2c8c4b36b1382a">loadAndUploadImage</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> <span class="keywordtype">char</span>* fileName, <span class="keywordtype">bool</span> allowDecompress, pvrvk::SecondaryCommandBuffer&amp; commandBuffer, IAssetProvider&amp; assetProvider,</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    pvrvk::ImageUsageFlags usageFlags = pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout = pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL,</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    Texture* outAssetTexture = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* stagingBufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00451"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html">  451</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structpvr_1_1utils_1_1_image_update_info.html">ImageUpdateInfo</a></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;{</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="comment">// 1D/Array texture and common for rest</span></div><div class="line"><a name="l00454"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#a9c2480ee85781549db081da54c7cbf7b">  454</a></span>&#160;    int32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#a9c2480ee85781549db081da54c7cbf7b">offsetX</a>; </div><div class="line"><a name="l00455"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#ae8eb6603e41f6af5b9ddfbe6d6485570">  455</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#ae8eb6603e41f6af5b9ddfbe6d6485570">imageWidth</a>; </div><div class="line"><a name="l00456"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#a8d9cfeb4d88791e650d994402d00511c">  456</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#a8d9cfeb4d88791e650d994402d00511c">dataWidth</a>; </div><div class="line"><a name="l00457"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#a6cde0ffe41f15363a6589bf287aa30d3">  457</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#a6cde0ffe41f15363a6589bf287aa30d3">arrayIndex</a>; </div><div class="line"><a name="l00458"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#a1b452f639a4e507f7d3bdfaf529da029">  458</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#a1b452f639a4e507f7d3bdfaf529da029">mipLevel</a>; </div><div class="line"><a name="l00459"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#a66c0abcd177d448a4b0a140321fa1427">  459</a></span>&#160;    <span class="keyword">const</span> <span class="keywordtype">void</span>* <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#a66c0abcd177d448a4b0a140321fa1427">data</a>; </div><div class="line"><a name="l00460"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#a35ffe0060a18ba6f85103107860e465a">  460</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#a35ffe0060a18ba6f85103107860e465a">dataSize</a>; </div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    <span class="comment">// 2D/ Array texture only</span></div><div class="line"><a name="l00463"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#a3bae3542769781673b17522db91c19b0">  463</a></span>&#160;    int32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#a3bae3542769781673b17522db91c19b0">offsetY</a>; </div><div class="line"><a name="l00464"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#a63830a23335c0e841e02b4f02f0363f7">  464</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#a63830a23335c0e841e02b4f02f0363f7">imageHeight</a>; </div><div class="line"><a name="l00465"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#a7088e032f08263a7d72acafbd6c93fca">  465</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#a7088e032f08263a7d72acafbd6c93fca">dataHeight</a>; </div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="comment">// cube/ Array Map only. Derive all states above</span></div><div class="line"><a name="l00468"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#a74171c9f0e1ea8f1eac9a991349389a6">  468</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#a74171c9f0e1ea8f1eac9a991349389a6">cubeFace</a>; </div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    <span class="comment">// 3D texture Only. Derive all states above Except arrayIndex</span></div><div class="line"><a name="l00471"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#af9bdb2f2512ec72d5669ae3b870d7fa5">  471</a></span>&#160;    int32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#af9bdb2f2512ec72d5669ae3b870d7fa5">offsetZ</a>; </div><div class="line"><a name="l00472"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_image_update_info.html#ac9fe2c31e80c1a067508d5d288f12801">  472</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html#ac9fe2c31e80c1a067508d5d288f12801">depth</a>; </div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html">ImageUpdateInfo</a>()</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        : offsetX(0), imageWidth(1), dataWidth(1), mipLevel(0), data(nullptr), dataSize(0), offsetY(0), imageHeight(1), dataHeight(1), cubeFace(0), offsetZ(0), depth(1)</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    {}</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;};</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a71cc4019e6c6315a8a714f4103bfe503">updateImage</a>(pvrvk::Device&amp; device, pvrvk::CommandBufferBase transferCommandBuffer, <a class="code" href="structpvr_1_1utils_1_1_image_update_info.html">ImageUpdateInfo</a>* updateInfos, uint32_t numUpdateInfos, pvrvk::Format format,</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    pvrvk::ImageLayout layout, <span class="keywordtype">bool</span> isCubeMap, <a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a>&amp; image, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator = <span class="keyword">nullptr</span>);</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00504"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">  504</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a>(pvrvk::Buffer&amp; buffer, <span class="keyword">const</span> <span class="keywordtype">void</span>* data, VkDeviceSize offset = 0, VkDeviceSize size = VK_WHOLE_SIZE, <span class="keywordtype">bool</span> flushMemory = <span class="keyword">false</span>)</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;{</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    <span class="keywordtype">void</span>* mapData = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    <span class="keywordtype">bool</span> unmap = <span class="keyword">false</span>;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    <span class="keywordflow">if</span> (!buffer-&gt;getDeviceMemory()-&gt;isMapped())</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    {</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        mapData = buffer-&gt;getDeviceMemory()-&gt;map(offset, size);</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;        unmap = <span class="keyword">true</span>;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    }</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    {</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        mapData = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(buffer-&gt;getDeviceMemory()-&gt;getMappedData()) + offset;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;    }</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    memcpy(mapData, data, (<span class="keywordtype">size_t</span>)size);</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="keywordflow">if</span> (static_cast&lt;uint32_t&gt;(buffer-&gt;getDeviceMemory()-&gt;getMemoryFlags() &amp; pvrvk::MemoryPropertyFlags::e_HOST_COHERENT_BIT) != 0) { flushMemory = <span class="keyword">false</span>; }</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    <span class="keywordflow">if</span> (flushMemory) { buffer-&gt;getDeviceMemory()-&gt;flushRange(offset, size); }</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="keywordflow">if</span> (unmap) { buffer-&gt;getDeviceMemory()-&gt;unmap(); }</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;}</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div><div class="line"><a name="l00535"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">  535</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">updateBufferUsingStagingBuffer</a>(pvrvk::Device&amp; device, pvrvk::Buffer&amp; buffer, pvrvk::CommandBufferBase uploadCmdBuffer, <span class="keyword">const</span> <span class="keywordtype">void</span>* data, VkDeviceSize offset = 0,</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    VkDeviceSize size = VK_WHOLE_SIZE, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* stagingBufferAllocator = <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;{</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    <span class="comment">// Updating memory via the use of staging buffers is necessary when memory is not host visible. In this case the buffer memory will be updated indirectly as follows:</span></div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    <span class="comment">//      1. Create a staging buffer</span></div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <span class="comment">//      2. map the staging buffer memory, update the memory, then unmap the buffer memory</span></div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    <span class="comment">//      3. Copy from the staging buffer to the target buffer</span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">pvr::utils::beginCommandBufferDebugLabel</a>(uploadCmdBuffer, pvrvk::DebugUtilsLabel(<span class="stringliteral">&quot;PVRUtilsVk::updateBufferUsingStagingBuffer&quot;</span>));</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    <span class="comment">// 1. Create a staging buffer</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    pvrvk::MemoryPropertyFlags memoryFlags = pvrvk::MemoryPropertyFlags::e_HOST_VISIBLE_BIT;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    pvrvk::Buffer stagingBuffer =</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;        <a class="code" href="namespacepvr_1_1utils.html#a1e975fe49bd5070e883c7b34f1b55cf5">pvr::utils::createBuffer</a>(device, pvrvk::BufferCreateInfo(size, pvrvk::BufferUsageFlags::e_TRANSFER_SRC_BIT), memoryFlags, memoryFlags, stagingBufferAllocator);</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;    <span class="comment">// 2. map (if required), then update the memory, then finally unmap (if required)</span></div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a>(stagingBuffer, data, offset, size, <span class="keyword">true</span>);</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <span class="comment">// 3. Copy from the staging buffer to the target buffer</span></div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    <span class="keyword">const</span> pvrvk::BufferCopy bufferCopy(0, offset, size);</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    uploadCmdBuffer-&gt;copyBuffer(stagingBuffer, buffer, 1, &amp;bufferCopy);</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">pvr::utils::endCommandBufferDebugLabel</a>(uploadCmdBuffer);</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;}</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a5d3d1522b9db9f69b91090f918ccc8c0">generateTextureAtlas</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> <a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a>* inputImages, pvrvk::Rect2Df* outUVs, uint32_t numImages, pvrvk::ImageLayout inputImageLayout,</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    pvrvk::ImageView* outImageView, TextureHeader* outDescriptor, pvrvk::CommandBufferBase cmdBuffer, pvrvk::ImageLayout finalLayout = pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL,</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags = vma::AllocationCreateFlags::e_NONE);</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div><div class="line"><a name="l00581"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_queue_populate_info.html">  581</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structpvr_1_1utils_1_1_queue_populate_info.html">QueuePopulateInfo</a></div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;{</div><div class="line"><a name="l00584"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_queue_populate_info.html#a8f6a04a2c21acef02ed848f4de285643">  584</a></span>&#160;    pvrvk::QueueFlags <a class="code" href="structpvr_1_1utils_1_1_queue_populate_info.html#a8f6a04a2c21acef02ed848f4de285643">queueFlags</a>;</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div><div class="line"><a name="l00587"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_queue_populate_info.html#ab303d9a7f5c55fcd9a13f272ae23b764">  587</a></span>&#160;    pvrvk::Surface <a class="code" href="structpvr_1_1utils_1_1_queue_populate_info.html#ab303d9a7f5c55fcd9a13f272ae23b764">surface</a>;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div><div class="line"><a name="l00590"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_queue_populate_info.html#ad38c982d524591f2b715b130a8c9f697">  590</a></span>&#160;    <span class="keywordtype">float</span> <a class="code" href="structpvr_1_1utils_1_1_queue_populate_info.html#ad38c982d524591f2b715b130a8c9f697">priority</a>;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_queue_populate_info.html#a5eeb3d84dac92d6718f2b6d7f03d653d">  595</a></span>&#160;    <a class="code" href="structpvr_1_1utils_1_1_queue_populate_info.html#a5eeb3d84dac92d6718f2b6d7f03d653d">QueuePopulateInfo</a>(pvrvk::QueueFlags queueFlags, <span class="keywordtype">float</span> priority = 1.0f) : queueFlags(queueFlags), priority(priority) {}</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;</div><div class="line"><a name="l00601"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_queue_populate_info.html#a8d5ad873b0ae0c6c8c82511c5e7a72aa">  601</a></span>&#160;    <a class="code" href="structpvr_1_1utils_1_1_queue_populate_info.html#a8d5ad873b0ae0c6c8c82511c5e7a72aa">QueuePopulateInfo</a>(pvrvk::QueueFlags queueFlags, pvrvk::Surface&amp; surface, <span class="keywordtype">float</span> priority = 1.0f) : queueFlags(queueFlags), surface(surface), priority(priority) {}</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;};</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00606"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_queue_access_info.html">  606</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structpvr_1_1utils_1_1_queue_access_info.html">QueueAccessInfo</a></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;{</div><div class="line"><a name="l00609"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_queue_access_info.html#a6d0e303c656d8312932d268db869596a">  609</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_queue_access_info.html#a6d0e303c656d8312932d268db869596a">familyId</a>;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;</div><div class="line"><a name="l00612"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_queue_access_info.html#ae5df4d78d8d64b5009b8c5a9e36c0e23">  612</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_queue_access_info.html#ae5df4d78d8d64b5009b8c5a9e36c0e23">queueId</a>;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00615"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_queue_access_info.html#a01adf09947e46f17ac7f924a3b5186f2">  615</a></span>&#160;    <a class="code" href="structpvr_1_1utils_1_1_queue_access_info.html#a01adf09947e46f17ac7f924a3b5186f2">QueueAccessInfo</a>() : familyId(static_cast&lt;uint32_t&gt;(-1)), queueId(static_cast&lt;uint32_t&gt;(-1)) {}</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;};</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;</div><div class="line"><a name="l00619"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_instance_layers.html">  619</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a> : <span class="keyword">public</span> pvrvk::VulkanLayerList</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;{</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    <a class="code" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a>(<span class="keywordtype">bool</span> forceLayers =</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;#ifdef DEBUG</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;                       <span class="keyword">true</span>);</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;                       <span class="keyword">false</span>);</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;};</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;</div><div class="line"><a name="l00633"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_instance_extensions.html">  633</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a> : <span class="keyword">public</span> pvrvk::VulkanExtensionList</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;{</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    <a class="code" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a>();</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;};</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00640"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_device_extensions.html">  640</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a> : <span class="keyword">public</span> pvrvk::VulkanExtensionList</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;{</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;    <a class="code" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a>();</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;};</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;pvrvk::Device <a class="code" href="namespacepvr_1_1utils.html#a34226196d1cd435e8f19abecc2d3b0eb">createDeviceAndQueues</a>(pvrvk::PhysicalDevice physicalDevice, <span class="keyword">const</span> <a class="code" href="structpvr_1_1utils_1_1_queue_populate_info.html">QueuePopulateInfo</a>* queueCreateInfos, uint32_t numQueueCreateInfos, <a class="code" href="structpvr_1_1utils_1_1_queue_access_info.html">QueueAccessInfo</a>* outAccessInfo,</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;    <span class="keyword">const</span> <a class="code" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a>&amp; deviceExtensions = <a class="code" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a>());</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;pvrvk::Swapchain <a class="code" href="namespacepvr_1_1utils.html#a3d992b548d4b9d5617bc2766f1dbdda9">createSwapchain</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> pvrvk::Surface&amp; surface, pvr::DisplayAttributes&amp; displayAttributes,</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    <span class="keyword">const</span> std::vector&lt;pvrvk::Format&gt;&amp; preferredColorFormats = std::vector&lt;pvrvk::Format&gt;(),</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;    pvrvk::ImageUsageFlags swapchainImageUsageFlags = pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT);</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;pvrvk::Swapchain <a class="code" href="namespacepvr_1_1utils.html#a3d992b548d4b9d5617bc2766f1dbdda9">createSwapchain</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> pvrvk::Surface&amp; surface, pvr::DisplayAttributes&amp; displayAttributes,</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;    pvrvk::ImageUsageFlags swapchainImageUsageFlags = pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT);</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="keywordtype">bool</span> isSupportedDepthStencilFormat(<span class="keyword">const</span> pvrvk::Device&amp; device, pvrvk::Format format);</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;pvrvk::Format getSupportedDepthStencilFormat(<span class="keyword">const</span> pvrvk::Device&amp; device, pvr::DisplayAttributes&amp; displayAttributes, std::vector&lt;pvrvk::Format&gt; preferredDepthFormats = {});</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;std::vector&lt;pvrvk::ImageView&gt; createDepthStencilImageAndViews(pvrvk::Device&amp; device, int32_t imageCount, pvrvk::Format depthFormat, <span class="keyword">const</span> pvrvk::Extent2D&amp; imageExtent,</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;    <span class="keyword">const</span> pvrvk::ImageUsageFlags&amp; imageUsageFlags = pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT | pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT,</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;    pvrvk::SampleCountFlags sampleCount = pvrvk::SampleCountFlags::e_1_BIT, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* dsImageAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> dsImageAllocationCreateFlags = vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT);</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a391224081fe950b01072c76a7a33fbac">createSwapchainAndDepthStencilImageAndViews</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> pvrvk::Surface&amp; surface, pvr::DisplayAttributes&amp; displayAttributes, pvrvk::Swapchain&amp; outSwapchain,</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    <a class="code" href="classpvr_1_1_multi.html">Multi&lt;pvrvk::ImageView&gt;</a>&amp; outDepthStencilImages, <span class="keyword">const</span> std::vector&lt;pvrvk::Format&gt;&amp; preferredColorFormats = std::vector&lt;pvrvk::Format&gt;(),</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;    <span class="keyword">const</span> std::vector&lt;pvrvk::Format&gt;&amp; preferredDepthStencilFormats = std::vector&lt;pvrvk::Format&gt;(),</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;    <span class="keyword">const</span> pvrvk::ImageUsageFlags&amp; swapchainImageUsageFlags = pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT,</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    <span class="keyword">const</span> pvrvk::ImageUsageFlags&amp; dsImageUsageFlags = pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT | pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT,</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* dsImageAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> dsImageAllocationCreateFlags = vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT);</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a391224081fe950b01072c76a7a33fbac">createSwapchainAndDepthStencilImageAndViews</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> pvrvk::Surface&amp; surface, pvr::DisplayAttributes&amp; displayAttributes, pvrvk::Swapchain&amp; outSwapchain,</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;    <a class="code" href="classpvr_1_1_multi.html">Multi&lt;pvrvk::ImageView&gt;</a>&amp; outDepthStencilImages, <span class="keyword">const</span> pvrvk::ImageUsageFlags&amp; swapchainImageUsageFlags = pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT,</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;    <span class="keyword">const</span> pvrvk::ImageUsageFlags&amp; dsImageUsageFlags = pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT | pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT,</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;    <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* dsImageAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> dsImageAllocationCreateFlags = vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT);</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;<span class="keyword">inline</span> pvrvk::RenderPass createRenderPass(pvrvk::Swapchain&amp; swapchain, pvrvk::ImageView* depthStencilImages,</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;    pvrvk::ImageLayout initialSwapchainLayout = pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout = pvrvk::ImageLayout::e_UNDEFINED,</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;    pvrvk::AttachmentLoadOp colorLoadOp = pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp = pvrvk::AttachmentStoreOp::e_STORE,</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;    pvrvk::AttachmentLoadOp depthStencilLoadOp = pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp = pvrvk::AttachmentStoreOp::e_DONT_CARE)</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;{</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;    pvrvk::RenderPassCreateInfo rpInfo;</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;    rpInfo.setAttachmentDescription(0,</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;        pvrvk::AttachmentDescription::createColorDescription(swapchain-&gt;getImageFormat(), initialSwapchainLayout, pvrvk::ImageLayout::e_PRESENT_SRC_KHR, colorLoadOp, colorStoreOp));</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;    pvrvk::SubpassDescription subpass;</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    subpass.setColorAttachmentReference(0, pvrvk::AttachmentReference(0, pvrvk::ImageLayout::e_COLOR_ATTACHMENT_OPTIMAL));</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;    <span class="keywordflow">if</span> (depthStencilImages != <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    {</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;        rpInfo.setAttachmentDescription(1,</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;            pvrvk::AttachmentDescription::createDepthStencilDescription(depthStencilImages[0]-&gt;getImage()-&gt;getFormat(), initialDepthStencilLayout,</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;                pvrvk::ImageLayout::e_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, depthStencilLoadOp, depthStencilStoreOp));</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        subpass.setDepthStencilAttachmentReference(pvrvk::AttachmentReference(1, pvrvk::ImageLayout::e_DEPTH_STENCIL_ATTACHMENT_OPTIMAL));</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;    }</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;    pvrvk::SubpassDependency dependencies[2];</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;    dependencies[0] = pvrvk::SubpassDependency(pvrvk::SubpassExternal, 0, pvrvk::PipelineStageFlags::e_BOTTOM_OF_PIPE_BIT, pvrvk::PipelineStageFlags::e_COLOR_ATTACHMENT_OUTPUT_BIT,</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        pvrvk::AccessFlags::e_NONE, pvrvk::AccessFlags::e_COLOR_ATTACHMENT_READ_BIT | pvrvk::AccessFlags::e_COLOR_ATTACHMENT_WRITE_BIT, pvrvk::DependencyFlags::e_BY_REGION_BIT);</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;    dependencies[1] = pvrvk::SubpassDependency(0, pvrvk::SubpassExternal, pvrvk::PipelineStageFlags::e_COLOR_ATTACHMENT_OUTPUT_BIT, pvrvk::PipelineStageFlags::e_BOTTOM_OF_PIPE_BIT,</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;        pvrvk::AccessFlags::e_COLOR_ATTACHMENT_READ_BIT | pvrvk::AccessFlags::e_COLOR_ATTACHMENT_WRITE_BIT, pvrvk::AccessFlags::e_NONE, pvrvk::DependencyFlags::e_BY_REGION_BIT);</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;    rpInfo.addSubpassDependencies(dependencies, ARRAY_SIZE(dependencies));</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;    rpInfo.setSubpass(0, subpass);</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;    pvrvk::RenderPass renderPass = swapchain-&gt;getDevice()-&gt;createRenderPass(rpInfo);</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;    renderPass-&gt;setObjectName(<span class="stringliteral">&quot;PVRUtilsVk::OnScreenRenderPass&quot;</span>);</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;    <span class="keywordflow">return</span> renderPass;</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;}</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="keyword">inline</span> std::vector&lt;pvrvk::Framebuffer&gt; createOnscreenFramebuffers(pvrvk::Swapchain&amp; swapchain, pvrvk::ImageView* depthStencilImages, <span class="keyword">const</span> pvrvk::RenderPass&amp; renderPass)</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;{</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    std::vector&lt;pvrvk::Framebuffer&gt; framebuffers;</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;    framebuffers.reserve(swapchain-&gt;getSwapchainLength());</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; swapchain-&gt;getSwapchainLength(); ++i)</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    {</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;        pvrvk::FramebufferCreateInfo framebufferInfo;</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;        framebufferInfo.setAttachment(0, swapchain-&gt;getImageView(i));</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;        framebufferInfo.setDimensions(swapchain-&gt;getDimension());</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;        <span class="keywordflow">if</span> (depthStencilImages) { framebufferInfo.setAttachment(1, depthStencilImages[i]); }</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;        framebufferInfo.setRenderPass(renderPass);</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;        framebuffers.push_back(swapchain-&gt;getDevice()-&gt;createFramebuffer(framebufferInfo));</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;        framebuffers.back()-&gt;setObjectName(std::string(<span class="stringliteral">&quot;PVRUtilsVk::OnScreenFrameBuffer [&quot;</span>) + std::to_string(i) + std::string(<span class="stringliteral">&quot;]&quot;</span>));</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;    }</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    <span class="keywordflow">return</span> framebuffers;</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;}</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;</div><div class="line"><a name="l00809"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#af3c27cb705f0f371580caad44b5763be">  809</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#af3c27cb705f0f371580caad44b5763be">createOnscreenFramebufferAndRenderPass</a>(pvrvk::Swapchain&amp; swapchain, pvrvk::ImageView* depthStencilImages, <a class="code" href="classpvr_1_1_multi.html">Multi&lt;pvrvk::Framebuffer&gt;</a>&amp; outFramebuffers,</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;    pvrvk::RenderPass&amp; outRenderPass, pvrvk::ImageLayout initialSwapchainLayout = pvrvk::ImageLayout::e_UNDEFINED,</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;    pvrvk::ImageLayout initialDepthStencilLayout = pvrvk::ImageLayout::e_UNDEFINED, pvrvk::AttachmentLoadOp colorLoadOp = pvrvk::AttachmentLoadOp::e_CLEAR,</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;    pvrvk::AttachmentStoreOp colorStoreOp = pvrvk::AttachmentStoreOp::e_STORE, pvrvk::AttachmentLoadOp depthStencilLoadOp = pvrvk::AttachmentLoadOp::e_CLEAR,</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;    pvrvk::AttachmentStoreOp depthStencilStoreOp = pvrvk::AttachmentStoreOp::e_DONT_CARE)</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;{</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;    outRenderPass =</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;        createRenderPass(swapchain, depthStencilImages, initialSwapchainLayout, initialDepthStencilLayout, colorLoadOp, colorStoreOp, depthStencilLoadOp, depthStencilStoreOp);</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;    <span class="keyword">auto</span> framebuffers = createOnscreenFramebuffers(swapchain, depthStencilImages, outRenderPass);</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;    outFramebuffers.<a class="code" href="classpvr_1_1_multi.html#a689f8a2da8d7decb53b75af7732c570d">resize</a>(swapchain-&gt;getSwapchainLength());</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;    std::copy_n(framebuffers.begin(), outFramebuffers.<a class="code" href="classpvr_1_1_multi.html#a2e662f3b39e54e6995421a1f15ed9103">size</a>(), &amp;outFramebuffers[0]);</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;}</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;</div><div class="line"><a name="l00851"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a800aecef7aa17bc651e2ee97b8e2c6d9">  851</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#af3c27cb705f0f371580caad44b5763be">createOnscreenFramebufferAndRenderPass</a>(pvrvk::Swapchain&amp; swapchain, pvrvk::ImageView* depthStencilImages, <a class="code" href="classpvr_1_1_multi.html">Multi&lt;pvrvk::Framebuffer&gt;</a>&amp; outFramebuffers,</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;    pvrvk::ImageLayout initialSwapchainLayout = pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout = pvrvk::ImageLayout::e_UNDEFINED,</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;    pvrvk::AttachmentLoadOp colorLoadOp = pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp = pvrvk::AttachmentStoreOp::e_STORE,</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    pvrvk::AttachmentLoadOp depthStencilLoadOp = pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp = pvrvk::AttachmentStoreOp::e_DONT_CARE)</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;{</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;    pvrvk::RenderPass dummy;</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#af3c27cb705f0f371580caad44b5763be">createOnscreenFramebufferAndRenderPass</a>(swapchain, depthStencilImages, outFramebuffers, dummy, initialSwapchainLayout, initialDepthStencilLayout, colorLoadOp, colorStoreOp,</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;        depthStencilLoadOp, depthStencilStoreOp);</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;}</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;</div><div class="line"><a name="l00864"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a1e9a18d03439c5efe7d88dbb3c16b783">  864</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a1e9a18d03439c5efe7d88dbb3c16b783">populateViewportStateCreateInfo</a>(<span class="keyword">const</span> pvrvk::Framebuffer&amp; framebuffer, pvrvk::PipelineViewportStateCreateInfo&amp; outCreateInfo)</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;{</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;    outCreateInfo.setViewportAndScissor(0,</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;        pvrvk::Viewport(0.f, 0.f, static_cast&lt;float&gt;(framebuffer-&gt;getDimensions().getWidth()), static_cast&lt;float&gt;(framebuffer-&gt;getDimensions().getHeight())),</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;        pvrvk::Rect2D(pvrvk::Offset2D(0, 0), pvrvk::Extent2D(framebuffer-&gt;getDimensions().getWidth(), framebuffer-&gt;getDimensions().getHeight())));</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;}</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;</div><div class="line"><a name="l00872"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vertex_bindings.html">  872</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a></div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;{</div><div class="line"><a name="l00875"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vertex_bindings.html#a74f6b69852fdb3031ef27bdffa5e2c99">  875</a></span>&#160;    std::string <a class="code" href="structpvr_1_1utils_1_1_vertex_bindings.html#a74f6b69852fdb3031ef27bdffa5e2c99">semanticName</a>;</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;</div><div class="line"><a name="l00878"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vertex_bindings.html#a0179ccaad4acf5af997d6f1032b13404">  878</a></span>&#160;    int16_t <a class="code" href="structpvr_1_1utils_1_1_vertex_bindings.html#a0179ccaad4acf5af997d6f1032b13404">location</a>;</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;};</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;</div><div class="line"><a name="l00882"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">  882</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;{</div><div class="line"><a name="l00885"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vertex_bindings___name.html#a20e78764d5aab84abdc052ea3e43a965">  885</a></span>&#160;    StringHash <a class="code" href="structpvr_1_1utils_1_1_vertex_bindings___name.html#a20e78764d5aab84abdc052ea3e43a965">semantic</a>;</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;</div><div class="line"><a name="l00888"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vertex_bindings___name.html#af8dc9152ecaae65489a154363a672747">  888</a></span>&#160;    StringHash <a class="code" href="structpvr_1_1utils_1_1_vertex_bindings___name.html#af8dc9152ecaae65489a154363a672747">variableName</a>;</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;};</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div><div class="line"><a name="l00898"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#ae0c2fd1a13ff3b5e9086e13ea4608c43">  898</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#ae0c2fd1a13ff3b5e9086e13ea4608c43">populateInputAssemblyFromMesh</a>(<span class="keyword">const</span> assets::Mesh&amp; mesh, <span class="keyword">const</span> <a class="code" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a>* bindingMap, uint16_t numBindings,</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;    pvrvk::PipelineVertexInputStateCreateInfo&amp; vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo&amp; inputAssemblerCreateInfo, uint16_t* numOutBuffers = <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;{</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    vertexCreateInfo.clear();</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    <span class="keywordflow">if</span> (numOutBuffers) { *numOutBuffers = 0; }</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;    uint16_t current = 0;</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;    <span class="keywordflow">while</span> (current &lt; numBindings)</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;    {</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;        <span class="keyword">auto</span> attr = mesh.getVertexAttributeByName(bindingMap[current].semanticName.c_str());</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;        <span class="keywordflow">if</span> (attr)</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;        {</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;            VertexAttributeLayout layout = attr-&gt;getVertexLayout();</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;            uint32_t stride = mesh.getStride(attr-&gt;getDataIndex());</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;            <span class="keywordflow">if</span> (numOutBuffers) { *numOutBuffers = std::max(static_cast&lt;uint16_t&gt;(attr-&gt;getDataIndex() + 1u), *numOutBuffers); }</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;            <span class="keyword">const</span> pvrvk::VertexInputAttributeDescription attribDesc(static_cast&lt;uint32_t&gt;(bindingMap[current].location), attr-&gt;getDataIndex(),</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;                <a class="code" href="namespacepvr_1_1utils.html#a116badc6ed0a108f3cc8ea515283a458">convertToPVRVkVertexInputFormat</a>(layout.dataType, layout.width), <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(layout.offset));</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;            <span class="keyword">const</span> pvrvk::VertexInputBindingDescription bindingDesc(attr-&gt;getDataIndex(), stride, pvrvk::VertexInputRate::e_VERTEX);</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;            vertexCreateInfo.addInputAttribute(attribDesc).addInputBinding(bindingDesc);</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;        }</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;        {</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;            Log(<span class="stringliteral">&quot;Could not find Attribute with Semantic %s in the supplied mesh. Will render without binding it, erroneously.&quot;</span>, bindingMap[current].semanticName.c_str());</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;        }</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;        ++current;</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;    }</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;    inputAssemblerCreateInfo.setPrimitiveTopology(<a class="code" href="namespacepvr_1_1utils.html#a6faa52cbc7bd9bc2ff02b680ca3c869d">convertToPVRVk</a>(mesh.getMeshInfo().primitiveType));</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;}</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;</div><div class="line"><a name="l00936"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a94c295af45dc688c117ebf5993e55373">  936</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#ae0c2fd1a13ff3b5e9086e13ea4608c43">populateInputAssemblyFromMesh</a>(<span class="keyword">const</span> assets::Mesh&amp; mesh, <span class="keyword">const</span> <a class="code" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a>* bindingMap, uint32_t numBindings,</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;    pvrvk::PipelineVertexInputStateCreateInfo&amp; vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo&amp; inputAssemblerCreateInfo, uint32_t* numOutBuffers = <span class="keyword">nullptr</span>)</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;{</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;    vertexCreateInfo.clear();</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    <span class="keywordflow">if</span> (numOutBuffers) { *numOutBuffers = 0; }</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    uint32_t current = 0;</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;    <span class="comment">// In this scenario, we will be using our own indexes instead of user provided ones, correlating them by names.</span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    vertexCreateInfo.clear();</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    <span class="keywordflow">while</span> (current &lt; numBindings)</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    {</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;        <span class="keyword">auto</span> attr = mesh.getVertexAttributeByName(bindingMap[current].semantic);</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;        <span class="keywordflow">if</span> (attr)</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;        {</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;            VertexAttributeLayout layout = attr-&gt;getVertexLayout();</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;            uint32_t stride = mesh.getStride(attr-&gt;getDataIndex());</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;            <span class="keywordflow">if</span> (numOutBuffers) { *numOutBuffers = std::max&lt;uint32_t&gt;(attr-&gt;getDataIndex() + 1u, *numOutBuffers); }</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;            <span class="keyword">const</span> pvrvk::VertexInputAttributeDescription attribDesc(current, attr-&gt;getDataIndex(), <a class="code" href="namespacepvr_1_1utils.html#a116badc6ed0a108f3cc8ea515283a458">convertToPVRVkVertexInputFormat</a>(layout.dataType, layout.width), layout.offset);</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;            <span class="keyword">const</span> pvrvk::VertexInputBindingDescription bindingDesc(attr-&gt;getDataIndex(), stride, pvrvk::VertexInputRate::e_VERTEX);</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;            vertexCreateInfo.addInputAttribute(attribDesc).addInputBinding(bindingDesc);</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;            inputAssemblerCreateInfo.setPrimitiveTopology(<a class="code" href="namespacepvr_1_1utils.html#a6faa52cbc7bd9bc2ff02b680ca3c869d">convertToPVRVk</a>(mesh.getMeshInfo().primitiveType));</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;        }</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;        {</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;            Log(<span class="stringliteral">&quot;Could not find Attribute with Semantic %s in the supplied mesh. Will render without binding it, erroneously.&quot;</span>, bindingMap[current].semantic.c_str());</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;        }</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;        ++current;</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;    }</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;}</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;</div><div class="line"><a name="l00981"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#ae6934715b675cba2e0a7454813b431a3">  981</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#ae6934715b675cba2e0a7454813b431a3">createSingleBuffersFromMesh</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> assets::Mesh&amp; mesh, pvrvk::Buffer&amp; outVbo, pvrvk::Buffer&amp; outIbo, pvrvk::CommandBuffer&amp; uploadCmdBuffer,</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;    <span class="keywordtype">bool</span>&amp; requiresCommandBufferSubmission, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags = vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;{</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;    requiresCommandBufferSubmission = <span class="keyword">false</span>;</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;    <span class="keywordtype">size_t</span> total = 0;</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; mesh.getNumDataElements(); ++i) { total += mesh.getDataSize(i); }</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;    pvrvk::MemoryPropertyFlags vboRequiredMemoryFlags = pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT;</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;    pvrvk::MemoryPropertyFlags vboOptimalMemoryFlags = vboRequiredMemoryFlags;</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;    outVbo = <a class="code" href="namespacepvr_1_1utils.html#a1e975fe49bd5070e883c7b34f1b55cf5">createBuffer</a>(device, pvrvk::BufferCreateInfo(static_cast&lt;uint32_t&gt;(total), pvrvk::BufferUsageFlags::e_VERTEX_BUFFER_BIT | pvrvk::BufferUsageFlags::e_TRANSFER_DST_BIT),</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;        vboRequiredMemoryFlags, vboOptimalMemoryFlags, bufferAllocator, vmaAllocationCreateFlags);</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    <span class="keywordtype">bool</span> isVboHostVisible = (outVbo-&gt;getDeviceMemory()-&gt;getMemoryFlags() &amp; pvrvk::MemoryPropertyFlags::e_HOST_VISIBLE_BIT) != 0;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;    <span class="keywordflow">if</span> (!isVboHostVisible) { requiresCommandBufferSubmission = <span class="keyword">true</span>; }</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;    <span class="keywordtype">size_t</span> current = 0;</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; mesh.getNumDataElements(); ++i)</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;    {</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;        <span class="keywordflow">if</span> (isVboHostVisible)</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;        { <a class="code" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a>(outVbo, static_cast&lt;const void*&gt;(mesh.getData(i)), static_cast&lt;uint32_t&gt;(current), <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(mesh.getDataSize(i)), <span class="keyword">true</span>); }</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;        {</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;            <a class="code" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">updateBufferUsingStagingBuffer</a>(device, outVbo, pvrvk::CommandBufferBase(uploadCmdBuffer), static_cast&lt;const void*&gt;(mesh.getData(i)), static_cast&lt;uint32_t&gt;(current),</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;                <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(mesh.getDataSize(i)), bufferAllocator);</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;        }</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;        current += mesh.getDataSize(i);</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;    }</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;    <span class="keywordflow">if</span> (mesh.getNumFaces())</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;    {</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;        pvrvk::MemoryPropertyFlags iboRequiredMemoryFlags = pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT;</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;        pvrvk::MemoryPropertyFlags iboOptimalMemoryFlags = iboRequiredMemoryFlags;</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;        outIbo = <a class="code" href="namespacepvr_1_1utils.html#a1e975fe49bd5070e883c7b34f1b55cf5">createBuffer</a>(device,</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;            pvrvk::BufferCreateInfo(static_cast&lt;uint32_t&gt;(mesh.getFaces().getDataSize()), pvrvk::BufferUsageFlags::e_INDEX_BUFFER_BIT | pvrvk::BufferUsageFlags::e_TRANSFER_DST_BIT),</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;            iboRequiredMemoryFlags, iboOptimalMemoryFlags, bufferAllocator, vmaAllocationCreateFlags);</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;        <span class="keywordtype">bool</span> isIboHostVisible = (outIbo-&gt;getDeviceMemory()-&gt;getMemoryFlags() &amp; pvrvk::MemoryPropertyFlags::e_HOST_VISIBLE_BIT) != 0;</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;        <span class="keywordflow">if</span> (!isIboHostVisible) { requiresCommandBufferSubmission = <span class="keyword">true</span>; }</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;        <span class="keywordflow">if</span> (isIboHostVisible)</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;        { <a class="code" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a>(outIbo, static_cast&lt;const void*&gt;(mesh.getFaces().getData()), 0, static_cast&lt;uint32_t&gt;(mesh.getFaces().getDataSize()), <span class="keyword">true</span>); }</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;        {</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;            <a class="code" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">updateBufferUsingStagingBuffer</a>(device, outIbo, pvrvk::CommandBufferBase(uploadCmdBuffer), static_cast&lt;const void*&gt;(mesh.getFaces().getData()), 0,</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;                static_cast&lt;uint32_t&gt;(mesh.getFaces().getDataSize()), bufferAllocator);</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;        }</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;    }</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;    {</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;        outIbo.reset();</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;    }</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;}</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;</div><div class="line"><a name="l01050"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a95e0a5be7c444548e52a74c2f40faaa5"> 1050</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a95e0a5be7c444548e52a74c2f40faaa5">createMultipleBuffersFromMesh</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> assets::Mesh&amp; mesh, std::vector&lt;pvrvk::Buffer&gt;&amp; outVbos, pvrvk::Buffer&amp; outIbo,</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;    pvrvk::CommandBuffer&amp; uploadCmdBuffer, <span class="keywordtype">bool</span>&amp; requiresCommandBufferSubmission, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator,</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags = vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;{</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;    requiresCommandBufferSubmission = <span class="keyword">false</span>;</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; mesh.getNumDataElements(); ++i)</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;    {</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;        pvrvk::MemoryPropertyFlags requiredMemoryFlags = pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT;</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;        pvrvk::MemoryPropertyFlags optimalMemoryFlags = requiredMemoryFlags;</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;        outVbos.emplace_back(<a class="code" href="namespacepvr_1_1utils.html#a1e975fe49bd5070e883c7b34f1b55cf5">createBuffer</a>(device,</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;            pvrvk::BufferCreateInfo(static_cast&lt;uint32_t&gt;(mesh.getDataSize(i)), pvrvk::BufferUsageFlags::e_VERTEX_BUFFER_BIT | pvrvk::BufferUsageFlags::e_TRANSFER_DST_BIT),</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;            requiredMemoryFlags, optimalMemoryFlags, bufferAllocator, vmaAllocationCreateFlags));</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;        <span class="keywordtype">bool</span> isBufferHostVisible = (outVbos.back()-&gt;getDeviceMemory()-&gt;getMemoryFlags() &amp; pvrvk::MemoryPropertyFlags::e_HOST_VISIBLE_BIT) != 0;</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;        <span class="keywordflow">if</span> (!isBufferHostVisible) { requiresCommandBufferSubmission = <span class="keyword">true</span>; }</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;        <span class="keywordflow">if</span> (isBufferHostVisible) { <a class="code" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a>(outVbos.back(), <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(mesh.getData(i)), 0, static_cast&lt;uint32_t&gt;(mesh.getDataSize(i)), <span class="keyword">true</span>); }</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;        {</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;            <a class="code" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">updateBufferUsingStagingBuffer</a>(device, outVbos.back(), pvrvk::CommandBufferBase(uploadCmdBuffer), <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(mesh.getData(i)), 0,</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;                static_cast&lt;uint32_t&gt;(mesh.getDataSize(i)), bufferAllocator);</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;        }</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;    }</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;    <span class="keywordflow">if</span> (mesh.getNumFaces())</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;    {</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;        pvrvk::MemoryPropertyFlags requiredMemoryFlags = pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT;</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;        pvrvk::MemoryPropertyFlags optimalMemoryFlags = requiredMemoryFlags;</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;        outIbo = <a class="code" href="namespacepvr_1_1utils.html#a1e975fe49bd5070e883c7b34f1b55cf5">createBuffer</a>(device,</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;            pvrvk::BufferCreateInfo(static_cast&lt;uint32_t&gt;(mesh.getFaces().getDataSize()), pvrvk::BufferUsageFlags::e_INDEX_BUFFER_BIT | pvrvk::BufferUsageFlags::e_TRANSFER_DST_BIT),</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;            requiredMemoryFlags, optimalMemoryFlags, bufferAllocator, vmaAllocationCreateFlags);</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;        <span class="keywordtype">bool</span> isBufferHostVisible = (outIbo-&gt;getDeviceMemory()-&gt;getMemoryFlags() &amp; pvrvk::MemoryPropertyFlags::e_HOST_VISIBLE_BIT) != 0;</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;        <span class="keywordflow">if</span> (!isBufferHostVisible) { requiresCommandBufferSubmission = <span class="keyword">true</span>; }</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;        <span class="keywordflow">if</span> (isBufferHostVisible)</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;        { <a class="code" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a>(outIbo, static_cast&lt;const void*&gt;(mesh.getFaces().getData()), 0, static_cast&lt;uint32_t&gt;(mesh.getFaces().getDataSize()), <span class="keyword">true</span>); }</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;        {</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;            <a class="code" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">updateBufferUsingStagingBuffer</a>(device, outIbo, pvrvk::CommandBufferBase(uploadCmdBuffer), static_cast&lt;const void*&gt;(mesh.getFaces().getData()), 0,</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;                static_cast&lt;uint32_t&gt;(mesh.getFaces().getDataSize()), bufferAllocator);</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;        }</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;    }</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;}</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> MeshIterator_, <span class="keyword">typename</span> VboInsertIterator_, <span class="keyword">typename</span> IboInsertIterator_&gt;</div><div class="line"><a name="l01115"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a06f94be9a865755c8bafaac56f286b01"> 1115</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a06f94be9a865755c8bafaac56f286b01">createSingleBuffersFromMeshes</a>(pvrvk::Device&amp; device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboInsertIterator_ outVbos, IboInsertIterator_ outIbos,</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;    pvrvk::CommandBuffer&amp; uploadCmdBuffer, <span class="keywordtype">bool</span>&amp; requiresCommandBufferSubmission, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator = <span class="keyword">nullptr</span>,</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;    <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags = vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;{</div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">pvr::utils::beginCommandBufferDebugLabel</a>(uploadCmdBuffer, pvrvk::DebugUtilsLabel(<span class="stringliteral">&quot;PVRUtilsVk::createSingleBuffersFromMeshes&quot;</span>));</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;    requiresCommandBufferSubmission = <span class="keyword">false</span>;</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    <span class="keywordflow">while</span> (meshIter != meshIterEnd)</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;    {</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;        <span class="keywordtype">size_t</span> total = 0;</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;        <span class="keywordflow">for</span> (uint32_t ii = 0; ii &lt; meshIter-&gt;getNumDataElements(); ++ii) { total += meshIter-&gt;getDataSize(ii); }</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;        pvrvk::Buffer vbo;</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;        pvrvk::MemoryPropertyFlags vboRequiredMemoryFlags = pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT;</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;        pvrvk::MemoryPropertyFlags vboOptimalMemoryFlags = vboRequiredMemoryFlags;</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;        vbo = <a class="code" href="namespacepvr_1_1utils.html#a1e975fe49bd5070e883c7b34f1b55cf5">createBuffer</a>(device, pvrvk::BufferCreateInfo(static_cast&lt;uint32_t&gt;(total), pvrvk::BufferUsageFlags::e_VERTEX_BUFFER_BIT | pvrvk::BufferUsageFlags::e_TRANSFER_DST_BIT),</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;            vboRequiredMemoryFlags, vboOptimalMemoryFlags, bufferAllocator, vmaAllocationCreateFlags);</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;        <span class="keywordtype">bool</span> isVboHostVisible = (vbo-&gt;getDeviceMemory()-&gt;getMemoryFlags() &amp; pvrvk::MemoryPropertyFlags::e_HOST_VISIBLE_BIT) != 0;</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;        <span class="keywordflow">if</span> (!isVboHostVisible) { requiresCommandBufferSubmission = <span class="keyword">true</span>; }</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;        <span class="keywordtype">size_t</span> current = 0;</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ii = 0; ii &lt; meshIter-&gt;getNumDataElements(); ++ii)</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;        {</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;            <span class="keywordflow">if</span> (isVboHostVisible)</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;            {</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;                <a class="code" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a>(vbo, (<span class="keyword">const</span> <span class="keywordtype">void</span>*)meshIter-&gt;getData(static_cast&lt;uint32_t&gt;(ii)), <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(current),</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;                    static_cast&lt;uint32_t&gt;(meshIter-&gt;getDataSize(static_cast&lt;uint32_t&gt;(ii))), <span class="keyword">true</span>);</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;            }</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;            {</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;                <a class="code" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">updateBufferUsingStagingBuffer</a>(device, vbo, pvrvk::CommandBufferBase(uploadCmdBuffer), (<span class="keyword">const</span> <span class="keywordtype">void</span>*)meshIter-&gt;getData(static_cast&lt;uint32_t&gt;(ii)),</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;                    <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(current), static_cast&lt;uint32_t&gt;(meshIter-&gt;getDataSize(static_cast&lt;uint32_t&gt;(ii))), bufferAllocator);</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;            }</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;            current += meshIter-&gt;getDataSize(static_cast&lt;uint32_t&gt;(ii));</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;        }</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;        outVbos = vbo;</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;        <span class="keywordflow">if</span> (meshIter-&gt;getNumFaces())</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;        {</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;            pvrvk::Buffer ibo;</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;            pvrvk::MemoryPropertyFlags iboRequiredMemoryFlags = pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT;</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;            pvrvk::MemoryPropertyFlags iboOptimalMemoryFlags = iboRequiredMemoryFlags;</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;            ibo = <a class="code" href="namespacepvr_1_1utils.html#a1e975fe49bd5070e883c7b34f1b55cf5">createBuffer</a>(device,</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;                pvrvk::BufferCreateInfo(</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;                    static_cast&lt;uint32_t&gt;(meshIter-&gt;getFaces().getDataSize()), pvrvk::BufferUsageFlags::e_INDEX_BUFFER_BIT | pvrvk::BufferUsageFlags::e_TRANSFER_DST_BIT),</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;                iboRequiredMemoryFlags, iboOptimalMemoryFlags, bufferAllocator, vmaAllocationCreateFlags);</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;            <span class="keywordtype">bool</span> isIboHostVisible = (ibo-&gt;getDeviceMemory()-&gt;getMemoryFlags() &amp; pvrvk::MemoryPropertyFlags::e_HOST_VISIBLE_BIT) != 0;</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;            <span class="keywordflow">if</span> (!isIboHostVisible) { requiresCommandBufferSubmission = <span class="keyword">true</span>; }</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;            <span class="keywordflow">if</span> (isIboHostVisible) { <a class="code" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a>(ibo, static_cast&lt;const void*&gt;(meshIter-&gt;getFaces().getData()), 0, meshIter-&gt;getFaces().getDataSize(), <span class="keyword">true</span>); }</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;            <span class="keywordflow">else</span></div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;            {</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;                <a class="code" href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">updateBufferUsingStagingBuffer</a>(device, ibo, pvrvk::CommandBufferBase(uploadCmdBuffer), static_cast&lt;const void*&gt;(meshIter-&gt;getFaces().getData()), 0,</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;                    meshIter-&gt;getFaces().getDataSize(), bufferAllocator);</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;            }</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;            outIbos = ibo;</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;        }</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;        {</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;            outIbos = pvrvk::Buffer();</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;        }</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;        ++outVbos;</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;        ++outIbos;</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;        ++meshIter;</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;    }</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">pvr::utils::endCommandBufferDebugLabel</a>(uploadCmdBuffer);</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;}</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> MeshIterator_, <span class="keyword">typename</span> VboContainer_, <span class="keyword">typename</span> IboContainer_&gt;</div><div class="line"><a name="l01209"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a4493b0c69e45e8b7af4d2fa32f763f23"> 1209</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a06f94be9a865755c8bafaac56f286b01">createSingleBuffersFromMeshes</a>(pvrvk::Device&amp; device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboContainer_&amp; outVbos,</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;    <span class="keyword">typename</span> VboContainer_::iterator vbos_where, IboContainer_&amp; outIbos, <span class="keyword">typename</span> IboContainer_::iterator ibos_where, pvrvk::CommandBuffer&amp; uploadCmdBuffer,</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;    <span class="keywordtype">bool</span>&amp; requiresCommandBufferSubmission, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags = vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;{</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a06f94be9a865755c8bafaac56f286b01">createSingleBuffersFromMeshes</a>(device, meshIter, meshIterEnd, std::inserter(outVbos, vbos_where), std::inserter(outIbos, ibos_where), uploadCmdBuffer,</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;        requiresCommandBufferSubmission, bufferAllocator, vmaAllocationCreateFlags);</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;}</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;</div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> VboInsertIterator_, <span class="keyword">typename</span> IboInsertIterator_&gt;</div><div class="line"><a name="l01234"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a8b77d306417876f431ed11fffde3a84f"> 1234</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a8b77d306417876f431ed11fffde3a84f">createSingleBuffersFromModel</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> assets::Model&amp; model, VboInsertIterator_ vbos, IboInsertIterator_ ibos, pvrvk::CommandBuffer&amp; uploadCmdBuffer,</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;    <span class="keywordtype">bool</span>&amp; requiresCommandBufferSubmission, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags = vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;{</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a06f94be9a865755c8bafaac56f286b01">createSingleBuffersFromMeshes</a>(device, model.beginMeshes(), model.endMeshes(), vbos, ibos, uploadCmdBuffer, requiresCommandBufferSubmission, bufferAllocator, vmaAllocationCreateFlags);</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;}</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> VboContainer_, <span class="keyword">typename</span> IboContainer_&gt;</div><div class="line"><a name="l01255"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#ac66fa9a9c7f8232c3f5aa3f41106cfea"> 1255</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#ac66fa9a9c7f8232c3f5aa3f41106cfea">appendSingleBuffersFromModel</a>(pvrvk::Device&amp; device, <span class="keyword">const</span> assets::Model&amp; model, VboContainer_&amp; vbos, IboContainer_&amp; ibos, pvrvk::CommandBuffer&amp; uploadCmdBuffer,</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;    <span class="keywordtype">bool</span>&amp; requiresCommandBufferSubmission, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags = vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;{</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;    <a class="code" href="namespacepvr_1_1utils.html#a06f94be9a865755c8bafaac56f286b01">createSingleBuffersFromMeshes</a>(device, model.beginMeshes(), model.endMeshes(), std::inserter(vbos, vbos.end()), std::inserter(ibos, ibos.end()), uploadCmdBuffer,</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;        requiresCommandBufferSubmission, bufferAllocator, vmaAllocationCreateFlags);</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;}</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#ad0c9ce4267ec635305fc87aba0b9d9c2">create3dPlaneMesh</a>(uint32_t width, uint32_t depth, <span class="keywordtype">bool</span> generateTexCoords, <span class="keywordtype">bool</span> generateNormalCoords, assets::Mesh&amp; outMesh);</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;std::vector&lt;unsigned char&gt; <a class="code" href="namespacepvr_1_1utils.html#a73c816f145c7217aaca0ddd95dddda1a">captureImageRegion</a>(pvrvk::Queue&amp; queue, pvrvk::CommandPool&amp; commandPool, <a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a>&amp; image, pvrvk::Offset3D srcOffset = pvrvk::Offset3D(0, 0, 0),</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;    pvrvk::Extent3D srcExtent = pvrvk::Extent3D(static_cast&lt;uint32_t&gt;(-1), static_cast&lt;uint32_t&gt;(-1), static_cast&lt;uint32_t&gt;(-1)),</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;    pvrvk::Format destinationImageFormat = pvrvk::Format::e_UNDEFINED, pvrvk::ImageLayout imageInitialLayout = pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL,</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;    pvrvk::ImageLayout imageFinalLayout = pvrvk::ImageLayout::e_TRANSFER_DST_OPTIMAL, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>);</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#acd56ceb5a0ccd36437b833a00a1bd9c5">saveImage</a>(pvrvk::Queue&amp; queue, pvrvk::CommandPool&amp; commandPool, <a class="code" href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvrvk::Image</a>&amp; image, <span class="keyword">const</span> pvrvk::ImageLayout imageInitialLayout, <span class="keyword">const</span> pvrvk::ImageLayout imageFinalLayout,</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;    <span class="keyword">const</span> std::string&amp; filename, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>, <span class="keyword">const</span> uint32_t screenshotScale = 1);</div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;<span class="keywordtype">bool</span> <a class="code" href="namespacepvr_1_1utils.html#af132fea9e3e9e5b4bc87004a4228096a">takeScreenshot</a>(pvrvk::Queue&amp; queue, pvrvk::CommandPool&amp; commandPool, pvrvk::Swapchain&amp; swapchain, <span class="keyword">const</span> uint32_t swapIndex, <span class="keyword">const</span> std::string&amp; screenshotFileName,</div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;    <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* bufferAllocator = <span class="keyword">nullptr</span>, <a class="code" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>* imageAllocator = <span class="keyword">nullptr</span>, <span class="keyword">const</span> uint32_t screenshotScale = 1);</div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;</div><div class="line"><a name="l01320"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07"> 1320</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07">isFormatDepthStencil</a>(pvrvk::Format format) { <span class="keywordflow">return</span> format &gt;= pvrvk::Format::e_D16_UNORM &amp;&amp; format &lt;= pvrvk::Format::e_D32_SFLOAT_S8_UINT; }</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;</div><div class="line"><a name="l01329"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a98e4ac9990af6eaf6b9bf0928f2bd07d"> 1329</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a98e4ac9990af6eaf6b9bf0928f2bd07d">populateClearValues</a>(<span class="keyword">const</span> pvrvk::RenderPass&amp; renderpass, <span class="keyword">const</span> pvrvk::ClearValue&amp; clearColor, <span class="keyword">const</span> pvrvk::ClearValue&amp; clearDepthStencilValue, pvrvk::ClearValue* outClearValues)</div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;{</div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; renderpass-&gt;getCreateInfo().getNumAttachmentDescription(); ++i)</div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;    {</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;        <span class="keyword">const</span> pvrvk::Format&amp; format = renderpass-&gt;getCreateInfo().getAttachmentDescription(i).getFormat();</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07">pvr::utils::isFormatDepthStencil</a>(format)) { outClearValues[i] = clearDepthStencilValue; }</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;        {</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;            outClearValues[i] = clearColor;</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;        }</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;    }</div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;}</div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;</div><div class="line"><a name="l01345"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#abbd1f30f49a0d36c9d932437e902d2bb"> 1345</a></span>&#160;<span class="keyword">inline</span> LogLevel <a class="code" href="namespacepvr_1_1utils.html#abbd1f30f49a0d36c9d932437e902d2bb">mapDebugUtilsMessageSeverityFlagsToLogLevel</a>(pvrvk::DebugUtilsMessageSeverityFlagsEXT flags)</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;{</div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;    <span class="keywordflow">if</span> ((flags &amp; pvrvk::DebugUtilsMessageSeverityFlagsEXT::e_INFO_BIT_EXT) != 0) { <span class="keywordflow">return</span> LogLevel::Information; }</div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;    <span class="keywordflow">if</span> ((flags &amp; pvrvk::DebugUtilsMessageSeverityFlagsEXT::e_WARNING_BIT_EXT) != 0) { <span class="keywordflow">return</span> LogLevel::Warning; }</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;    <span class="keywordflow">if</span> ((flags &amp; pvrvk::DebugUtilsMessageSeverityFlagsEXT::e_VERBOSE_BIT_EXT) != 0) { <span class="keywordflow">return</span> LogLevel::Debug; }</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;    <span class="keywordflow">if</span> ((flags &amp; pvrvk::DebugUtilsMessageSeverityFlagsEXT::e_ERROR_BIT_EXT) != 0) { <span class="keywordflow">return</span> LogLevel::Error; }</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;    <span class="keywordflow">return</span> LogLevel::Information;</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;}</div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;</div><div class="line"><a name="l01357"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#aee21903727c73558ad8e3cf936917344"> 1357</a></span>&#160;<span class="keyword">inline</span> LogLevel <a class="code" href="namespacepvr_1_1utils.html#aee21903727c73558ad8e3cf936917344">mapDebugReportFlagsToLogLevel</a>(pvrvk::DebugReportFlagsEXT flags)</div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;{</div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;    <span class="keywordflow">if</span> ((flags &amp; pvrvk::DebugReportFlagsEXT::e_INFORMATION_BIT_EXT) != 0) { <span class="keywordflow">return</span> LogLevel::Information; }</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;    <span class="keywordflow">if</span> ((flags &amp; pvrvk::DebugReportFlagsEXT::e_WARNING_BIT_EXT) != 0) { <span class="keywordflow">return</span> LogLevel::Warning; }</div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;    <span class="keywordflow">if</span> ((flags &amp; pvrvk::DebugReportFlagsEXT::e_PERFORMANCE_WARNING_BIT_EXT) != 0) { <span class="keywordflow">return</span> LogLevel::Performance; }</div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;    <span class="keywordflow">if</span> ((flags &amp; pvrvk::DebugReportFlagsEXT::e_ERROR_BIT_EXT) != 0) { <span class="keywordflow">return</span> LogLevel::Error; }</div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;    <span class="keywordflow">if</span> ((flags &amp; pvrvk::DebugReportFlagsEXT::e_DEBUG_BIT_EXT) != 0) { <span class="keywordflow">return</span> LogLevel::Debug; }</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;    <span class="keywordflow">return</span> LogLevel::Information;</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;}</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;VKAPI_ATTR VkBool32 VKAPI_CALL <a class="code" href="namespacepvr_1_1utils.html#aaf3d187bfb119271fea887f28268699a">throwOnErrorDebugUtilsMessengerCallback</a>(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes,</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;    <span class="keyword">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, <span class="keywordtype">void</span>* pUserData);</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;</div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;VKAPI_ATTR VkBool32 VKAPI_CALL <a class="code" href="namespacepvr_1_1utils.html#a5e37e4f2f8723d81f2f60ff7c9ffebdf">logMessageDebugUtilsMessengerCallback</a>(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes,</div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;    <span class="keyword">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, <span class="keywordtype">void</span>* pUserData);</div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;</div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;VKAPI_ATTR VkBool32 VKAPI_CALL <a class="code" href="namespacepvr_1_1utils.html#a54f2bb511b50d2c11ddc7377a60714ad">throwOnErrorDebugReportCallback</a>(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t <span class="keywordtype">object</span>, <span class="keywordtype">size_t</span> location,</div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;    int32_t messageCode, <span class="keyword">const</span> <span class="keywordtype">char</span>* pLayerPrefix, <span class="keyword">const</span> <span class="keywordtype">char</span>* pMessage, <span class="keywordtype">void</span>* pUserData);</div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;VKAPI_ATTR VkBool32 VKAPI_CALL <a class="code" href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">logMessageDebugReportCallback</a>(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t <span class="keywordtype">object</span>, <span class="keywordtype">size_t</span> location,</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;    int32_t messageCode, <span class="keyword">const</span> <span class="keywordtype">char</span>* pLayerPrefix, <span class="keyword">const</span> <span class="keywordtype">char</span>* pMessage, <span class="keywordtype">void</span>* pUserData);</div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;</div><div class="line"><a name="l01415"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vulkan_version.html"> 1415</a></span>&#160;<span class="keyword">struct </span><a class="code" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a></div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;{</div><div class="line"><a name="l01418"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vulkan_version.html#ae034e617f8481394b0d37b6ddaa228fd"> 1418</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_vulkan_version.html#ae034e617f8481394b0d37b6ddaa228fd">majorV</a>;</div><div class="line"><a name="l01420"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vulkan_version.html#a6c8a350c06cf3c659a092f0688f860b2"> 1420</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_vulkan_version.html#a6c8a350c06cf3c659a092f0688f860b2">minorV</a>;</div><div class="line"><a name="l01422"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vulkan_version.html#a3e1b806e01b77ae8589182a3d55cb00d"> 1422</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_vulkan_version.html#a3e1b806e01b77ae8589182a3d55cb00d">patchV</a>;</div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;</div><div class="line"><a name="l01428"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vulkan_version.html#a93aa7e756fb29313e3556bb4f5c10f3a"> 1428</a></span>&#160;    <a class="code" href="structpvr_1_1utils_1_1_vulkan_version.html#a93aa7e756fb29313e3556bb4f5c10f3a">VulkanVersion</a>(uint32_t majorV = 1, uint32_t minorV = 1, uint32_t patchV = 0) : majorV(majorV), minorV(minorV), patchV(patchV) {}</div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;</div><div class="line"><a name="l01432"></a><span class="lineno"><a class="line" href="structpvr_1_1utils_1_1_vulkan_version.html#a4a7dfa46502a507457263578dd48e572"> 1432</a></span>&#160;    uint32_t <a class="code" href="structpvr_1_1utils_1_1_vulkan_version.html#a4a7dfa46502a507457263578dd48e572">toVulkanVersion</a>() { <span class="keywordflow">return</span> VK_MAKE_VERSION(majorV, minorV, patchV); }</div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;};</div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;</div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;pvrvk::Instance <a class="code" href="namespacepvr_1_1utils.html#a680ef5943947e565f7d14aa9ff0393d9">createInstance</a>(<span class="keyword">const</span> std::string&amp; applicationName, <a class="code" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a> apiVersion = <a class="code" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a>(), <span class="keyword">const</span> <a class="code" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a>&amp; instanceExtensions = <a class="code" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a>(),</div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;    <span class="keyword">const</span> <a class="code" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a>&amp; instanceLayers = <a class="code" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a>());</div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;</div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;pvrvk::Surface <a class="code" href="namespacepvr_1_1utils.html#a73851a7eda7a39c5f4e8449ec08ba561">createSurface</a>(pvrvk::Instance&amp; instance, pvrvk::PhysicalDevice&amp; physicalDevice, <span class="keywordtype">void</span>* window, <span class="keywordtype">void</span>* display, <span class="keywordtype">void</span>* connection);</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;</div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacepvr_1_1utils.html#a6bbf98fde377992e9e7e0d23f38a9dcc">getMemoryTypeIndex</a>(<span class="keyword">const</span> pvrvk::PhysicalDevice&amp; physicalDevice, <span class="keyword">const</span> uint32_t allowedMemoryTypeBits, <span class="keyword">const</span> pvrvk::MemoryPropertyFlags requiredMemoryProperties,</div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;    <span class="keyword">const</span> pvrvk::MemoryPropertyFlags optimalMemoryProperties, uint32_t&amp; outMemoryTypeIndex, pvrvk::MemoryPropertyFlags&amp; outMemoryPropertyFlags);</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;</div><div class="line"><a name="l01473"></a><span class="lineno"><a class="line" href="namespacepvr_1_1utils.html#a59222cc49624a76fab4d4f65e3337ac3"> 1473</a></span>&#160;<span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacepvr_1_1utils.html#a59222cc49624a76fab4d4f65e3337ac3">isImageUsageSupportedBySurface</a>(<span class="keyword">const</span> pvrvk::SurfaceCapabilitiesKHR&amp; surfaceCapabilities, pvrvk::ImageUsageFlags imageUsage)</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;{</div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;    <span class="keywordflow">return</span> (static_cast&lt;uint32_t&gt;(surfaceCapabilities.getSupportedUsageFlags() &amp; imageUsage) != 0);</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;}</div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;} <span class="comment">// namespace utils</span></div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;} <span class="comment">// namespace pvr</span></div><div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_ac9fe2c31e80c1a067508d5d288f12801"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#ac9fe2c31e80c1a067508d5d288f12801">pvr::utils::ImageUpdateInfo::depth</a></div><div class="ttdeci">uint32_t depth</div><div class="ttdoc">Valid for texture updates only. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:472</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a5503c76488af3bca91058f4daa58ecfe"><div class="ttname"><a href="namespacepvr_1_1utils.html#a5503c76488af3bca91058f4daa58ecfe">pvr::utils::createImage</a></div><div class="ttdeci">pvrvk::Image createImage(pvrvk::Device device, const pvrvk::ImageCreateInfo &amp;createInfo, pvrvk::MemoryPropertyFlags requiredMemoryFlags=pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</div><div class="ttdoc">create a new Image(sparse or with memory backing, depending on flags . The user should not call bindM...</div></div>
<div class="ttc" id="_multi_object_8h_html"><div class="ttname"><a href="_multi_object_8h.html">MultiObject.h</a></div><div class="ttdoc">This file contains the Multi&lt;T&gt; class template, which is the usual container for objects that must be...</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_af3c27cb705f0f371580caad44b5763be"><div class="ttname"><a href="namespacepvr_1_1utils.html#af3c27cb705f0f371580caad44b5763be">pvr::utils::createOnscreenFramebufferAndRenderPass</a></div><div class="ttdeci">void createOnscreenFramebufferAndRenderPass(pvrvk::Swapchain &amp;swapchain, pvrvk::ImageView *depthStencilImages, Multi&lt; pvrvk::Framebuffer &gt; &amp;outFramebuffers, pvrvk::RenderPass &amp;outRenderPass, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::AttachmentLoadOp colorLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp=pvrvk::AttachmentStoreOp::e_STORE, pvrvk::AttachmentLoadOp depthStencilLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp=pvrvk::AttachmentStoreOp::e_DONT_CARE)</div><div class="ttdoc">Create a pvrvk::Framebuffer and RenderPass to use for &amp;#39;default&amp;#39; rendering to the &amp;#39;onscreen&amp;#39; color ima...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:809</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a0bd6e8b8a62c678202323873aeda6115"><div class="ttname"><a href="namespacepvr_1_1utils.html#a0bd6e8b8a62c678202323873aeda6115">pvr::utils::uploadImageAndView</a></div><div class="ttdeci">pvrvk::ImageView uploadImageAndView(pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</div><div class="ttdoc">Uploads an image to gpu. The upload command and staging buffers are recorded in the commandbuffer...</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vertex_bindings___name_html_af8dc9152ecaae65489a154363a672747"><div class="ttname"><a href="structpvr_1_1utils_1_1_vertex_bindings___name.html#af8dc9152ecaae65489a154363a672747">pvr::utils::VertexBindings_Name::variableName</a></div><div class="ttdeci">StringHash variableName</div><div class="ttdoc">Shader attribute name.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:888</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a93735fa36d5aedc03cf746dfa208a4b5"><div class="ttname"><a href="namespacepvr_1_1utils.html#a93735fa36d5aedc03cf746dfa208a4b5">pvr::utils::inferAspectFromFormat</a></div><div class="ttdeci">pvrvk::ImageAspectFlags inferAspectFromFormat(pvrvk::Format format)</div><div class="ttdoc">Infers the pvrvk::ImageAspectFlags from the pvrvk::Format.</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_a6cde0ffe41f15363a6589bf287aa30d3"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#a6cde0ffe41f15363a6589bf287aa30d3">pvr::utils::ImageUpdateInfo::arrayIndex</a></div><div class="ttdeci">uint32_t arrayIndex</div><div class="ttdoc">Valid for 1D,2D and Cube texture updates. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:457</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a54f2bb511b50d2c11ddc7377a60714ad"><div class="ttname"><a href="namespacepvr_1_1utils.html#a54f2bb511b50d2c11ddc7377a60714ad">pvr::utils::throwOnErrorDebugReportCallback</a></div><div class="ttdeci">VKAPI_ATTR VkBool32 VKAPI_CALL throwOnErrorDebugReportCallback(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</div><div class="ttdoc">An application DebugReportCallback function providing logging for various events. The callback will a...</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a71cc4019e6c6315a8a714f4103bfe503"><div class="ttname"><a href="namespacepvr_1_1utils.html#a71cc4019e6c6315a8a714f4103bfe503">pvr::utils::updateImage</a></div><div class="ttdeci">void updateImage(pvrvk::Device &amp;device, pvrvk::CommandBufferBase transferCommandBuffer, ImageUpdateInfo *updateInfos, uint32_t numUpdateInfos, pvrvk::Format format, pvrvk::ImageLayout layout, bool isCubeMap, pvrvk::Image &amp;image, vma::Allocator *bufferAllocator=nullptr)</div><div class="ttdoc">Utility function to update an image&amp;#39;s data. This function will record the update of the image in the ...</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_debug_utils_callbacks_html_a9e94e7d45269071a64d86419c18df205"><div class="ttname"><a href="structpvr_1_1utils_1_1_debug_utils_callbacks.html#a9e94e7d45269071a64d86419c18df205">pvr::utils::DebugUtilsCallbacks::debugCallbacks</a></div><div class="ttdeci">pvrvk::DebugReportCallback debugCallbacks[2]</div><div class="ttdoc">A set of debug report callbacks which may be used when VK_EXT_debug_report is supported and enabled v...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:75</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a1bcac1e9af1869244329d12c291200a5"><div class="ttname"><a href="namespacepvr_1_1utils.html#a1bcac1e9af1869244329d12c291200a5">pvr::utils::getDepthStencilBits</a></div><div class="ttdeci">void getDepthStencilBits(pvrvk::Format format, uint32_t &amp;depthBits, uint32_t &amp;stencilBits)</div><div class="ttdoc">Determines the number of depth and stencil bits per pixel for the given pvrvk::Format.</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a8b77d306417876f431ed11fffde3a84f"><div class="ttname"><a href="namespacepvr_1_1utils.html#a8b77d306417876f431ed11fffde3a84f">pvr::utils::createSingleBuffersFromModel</a></div><div class="ttdeci">void createSingleBuffersFromModel(pvrvk::Device &amp;device, const assets::Model &amp;model, VboInsertIterator_ vbos, IboInsertIterator_ ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="ttdoc">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inse...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1234</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a7eaec27096b06e097a3ead372e30c68c"><div class="ttname"><a href="namespacepvr_1_1utils.html#a7eaec27096b06e097a3ead372e30c68c">pvr::utils::beginQueueDebugLabel</a></div><div class="ttdeci">void beginQueueDebugLabel(pvrvk::Queue queue, const pvrvk::DebugUtilsLabel &amp;labelInfo)</div><div class="ttdoc">Begins identifying a region of work submitted to this queue. The calls to beginDebugUtilsLabel and en...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:89</div></div>
<div class="ttc" id="_convert_to_p_v_r_vk_types_8h_html"><div class="ttname"><a href="_convert_to_p_v_r_vk_types_8h.html">ConvertToPVRVkTypes.h</a></div><div class="ttdoc">Contains conversions of pvr Enumerations to Vulkan types. </div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_a35ffe0060a18ba6f85103107860e465a"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#a35ffe0060a18ba6f85103107860e465a">pvr::utils::ImageUpdateInfo::dataSize</a></div><div class="ttdeci">uint32_t dataSize</div><div class="ttdoc">Valid for all. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:460</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a73c816f145c7217aaca0ddd95dddda1a"><div class="ttname"><a href="namespacepvr_1_1utils.html#a73c816f145c7217aaca0ddd95dddda1a">pvr::utils::captureImageRegion</a></div><div class="ttdeci">std::vector&lt; unsigned char &gt; captureImageRegion(pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Image &amp;image, pvrvk::Offset3D srcOffset=pvrvk::Offset3D(0, 0, 0), pvrvk::Extent3D srcExtent=pvrvk::Extent3D(static_cast&lt; uint32_t &gt;(-1), static_cast&lt; uint32_t &gt;(-1), static_cast&lt; uint32_t &gt;(-1)), pvrvk::Format destinationImageFormat=pvrvk::Format::e_UNDEFINED, pvrvk::ImageLayout imageInitialLayout=pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL, pvrvk::ImageLayout imageFinalLayout=pvrvk::ImageLayout::e_TRANSFER_DST_OPTIMAL, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr)</div><div class="ttdoc">Retrieves and returns the contents of a particular image region. Note that the image must have been c...</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_a63830a23335c0e841e02b4f02f0363f7"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#a63830a23335c0e841e02b4f02f0363f7">pvr::utils::ImageUpdateInfo::imageHeight</a></div><div class="ttdeci">uint32_t imageHeight</div><div class="ttdoc">Valid for 2D, 3D and Cube texture updates. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:464</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_queue_populate_info_html"><div class="ttname"><a href="structpvr_1_1utils_1_1_queue_populate_info.html">pvr::utils::QueuePopulateInfo</a></div><div class="ttdoc">A structure encapsulating the set of queue flags required for a particular queue retrieved via the he...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:581</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a6bbf98fde377992e9e7e0d23f38a9dcc"><div class="ttname"><a href="namespacepvr_1_1utils.html#a6bbf98fde377992e9e7e0d23f38a9dcc">pvr::utils::getMemoryTypeIndex</a></div><div class="ttdeci">void getMemoryTypeIndex(const pvrvk::PhysicalDevice &amp;physicalDevice, const uint32_t allowedMemoryTypeBits, const pvrvk::MemoryPropertyFlags requiredMemoryProperties, const pvrvk::MemoryPropertyFlags optimalMemoryProperties, uint32_t &amp;outMemoryTypeIndex, pvrvk::MemoryPropertyFlags &amp;outMemoryPropertyFlags)</div><div class="ttdoc">Utility function for retrieving a memory type index for a suitable memory type which supports the mem...</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vulkan_version_html"><div class="ttname"><a href="structpvr_1_1utils_1_1_vulkan_version.html">pvr::utils::VulkanVersion</a></div><div class="ttdoc">The VulkanVersion structure provides an easy mechanism for constructing the Vulkan version for use wh...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1415</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_ae0c2fd1a13ff3b5e9086e13ea4608c43"><div class="ttname"><a href="namespacepvr_1_1utils.html#ae0c2fd1a13ff3b5e9086e13ea4608c43">pvr::utils::populateInputAssemblyFromMesh</a></div><div class="ttdeci">void populateInputAssemblyFromMesh(const assets::Mesh &amp;mesh, const VertexBindings *bindingMap, uint16_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint16_t *numOutBuffers=nullptr)</div><div class="ttdoc">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding V...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:898</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vertex_bindings_html"><div class="ttname"><a href="structpvr_1_1utils_1_1_vertex_bindings.html">pvr::utils::VertexBindings</a></div><div class="ttdoc">Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:872</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a7b2d4df80d31e3e63923ab1d68152ace"><div class="ttname"><a href="namespacepvr_1_1utils.html#a7b2d4df80d31e3e63923ab1d68152ace">pvr::utils::getNumSamplesFromSampleCountFlags</a></div><div class="ttdeci">uint8_t getNumSamplesFromSampleCountFlags(pvrvk::SampleCountFlags sampleCountFlags)</div><div class="ttdoc">Convert pvrvk sample count to the number of samples it is equivalent to</div><div class="ttdef"><b>Definition:</b> HelperVk.h:34</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_queue_populate_info_html_a5eeb3d84dac92d6718f2b6d7f03d653d"><div class="ttname"><a href="structpvr_1_1utils_1_1_queue_populate_info.html#a5eeb3d84dac92d6718f2b6d7f03d653d">pvr::utils::QueuePopulateInfo::QueuePopulateInfo</a></div><div class="ttdeci">QueuePopulateInfo(pvrvk::QueueFlags queueFlags, float priority=1.0f)</div><div class="ttdoc">Constructor for a QueuePopulateInfo requiring that a set of queue flags is provided.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:595</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a1e975fe49bd5070e883c7b34f1b55cf5"><div class="ttname"><a href="namespacepvr_1_1utils.html#a1e975fe49bd5070e883c7b34f1b55cf5">pvr::utils::createBuffer</a></div><div class="ttdeci">pvrvk::Buffer createBuffer(pvrvk::Device device, const pvrvk::BufferCreateInfo &amp;createInfo, pvrvk::MemoryPropertyFlags requiredMemoryFlags, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="ttdoc">Create a new buffer object and (optionally) allocate and bind memory for it</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vertex_bindings_html_a74f6b69852fdb3031ef27bdffa5e2c99"><div class="ttname"><a href="structpvr_1_1utils_1_1_vertex_bindings.html#a74f6b69852fdb3031ef27bdffa5e2c99">pvr::utils::VertexBindings::semanticName</a></div><div class="ttdeci">std::string semanticName</div><div class="ttdoc">Effect semantic.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:875</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_a8d9cfeb4d88791e650d994402d00511c"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#a8d9cfeb4d88791e650d994402d00511c">pvr::utils::ImageUpdateInfo::dataWidth</a></div><div class="ttdeci">uint32_t dataWidth</div><div class="ttdoc">Valid for all. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:456</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_ae3adba7320aa2b924adc48cfa5e043ed"><div class="ttname"><a href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">pvr::utils::insertDebugUtilsLabel</a></div><div class="ttdeci">void insertDebugUtilsLabel(pvrvk::CommandBufferBase commandBufferBase, const pvrvk::DebugUtilsLabel &amp;labelInfo)</div><div class="ttdoc">Inserts a single debug label any time.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:135</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_queue_populate_info_html_a8d5ad873b0ae0c6c8c82511c5e7a72aa"><div class="ttname"><a href="structpvr_1_1utils_1_1_queue_populate_info.html#a8d5ad873b0ae0c6c8c82511c5e7a72aa">pvr::utils::QueuePopulateInfo::QueuePopulateInfo</a></div><div class="ttdeci">QueuePopulateInfo(pvrvk::QueueFlags queueFlags, pvrvk::Surface &amp;surface, float priority=1.0f)</div><div class="ttdoc">Constructor for a QueuePopulateInfo requiring that a set of queue flags and a surface are provided...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:601</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_a66c0abcd177d448a4b0a140321fa1427"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#a66c0abcd177d448a4b0a140321fa1427">pvr::utils::ImageUpdateInfo::data</a></div><div class="ttdeci">const void * data</div><div class="ttdoc">Valid for all. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:459</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a59222cc49624a76fab4d4f65e3337ac3"><div class="ttname"><a href="namespacepvr_1_1utils.html#a59222cc49624a76fab4d4f65e3337ac3">pvr::utils::isImageUsageSupportedBySurface</a></div><div class="ttdeci">bool isImageUsageSupportedBySurface(const pvrvk::SurfaceCapabilitiesKHR &amp;surfaceCapabilities, pvrvk::ImageUsageFlags imageUsage)</div><div class="ttdoc">Utility function used to determine whether the SurfaceCapabilitiesKHR supportedUsageFlags member cont...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1473</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_ad7010e7802edc5e1cc101034ac386d37"><div class="ttname"><a href="namespacepvr_1_1utils.html#ad7010e7802edc5e1cc101034ac386d37">pvr::utils::loadAndUploadImageAndView</a></div><div class="ttdeci">pvrvk::ImageView loadAndUploadImageAndView(pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</div><div class="ttdoc">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffe...</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a680ef5943947e565f7d14aa9ff0393d9"><div class="ttname"><a href="namespacepvr_1_1utils.html#a680ef5943947e565f7d14aa9ff0393d9">pvr::utils::createInstance</a></div><div class="ttdeci">pvrvk::Instance createInstance(const std::string &amp;applicationName, VulkanVersion apiVersion=VulkanVersion(), const InstanceExtensions &amp;instanceExtensions=InstanceExtensions(), const InstanceLayers &amp;instanceLayers=InstanceLayers())</div><div class="ttdoc">Utility function for creating a Vulkan instance and supported physical devices using the appropriatel...</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a6faa52cbc7bd9bc2ff02b680ca3c869d"><div class="ttname"><a href="namespacepvr_1_1utils.html#a6faa52cbc7bd9bc2ff02b680ca3c869d">pvr::utils::convertToPVRVk</a></div><div class="ttdeci">pvrvk::IndexType convertToPVRVk(IndexType type)</div><div class="ttdoc">Convert a pvr::IndexType to its Native, Vulkan representation.</div><div class="ttdef"><b>Definition:</b> ConvertToPVRVkTypes.h:49</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_ad0c9ce4267ec635305fc87aba0b9d9c2"><div class="ttname"><a href="namespacepvr_1_1utils.html#ad0c9ce4267ec635305fc87aba0b9d9c2">pvr::utils::create3dPlaneMesh</a></div><div class="ttdeci">void create3dPlaneMesh(uint32_t width, uint32_t depth, bool generateTexCoords, bool generateNormalCoords, assets::Mesh &amp;outMesh)</div><div class="ttdoc">Creates a 3d plane mesh based on the width and depth specified. Texture coordinates and normal coordi...</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_ac66fa9a9c7f8232c3f5aa3f41106cfea"><div class="ttname"><a href="namespacepvr_1_1utils.html#ac66fa9a9c7f8232c3f5aa3f41106cfea">pvr::utils::appendSingleBuffersFromModel</a></div><div class="ttdeci">void appendSingleBuffersFromModel(pvrvk::Device &amp;device, const assets::Model &amp;model, VboContainer_ &amp;vbos, IboContainer_ &amp;ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="ttdoc">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appe...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1255</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a12e6adce5bcec23564fd67553c9f4088"><div class="ttname"><a href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">pvr::utils::endCommandBufferDebugLabel</a></div><div class="ttdeci">void endCommandBufferDebugLabel(pvrvk::CommandBufferBase commandBufferBase)</div><div class="ttdoc">Ends a label region of work submitted to this base command buffer.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:121</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vertex_bindings___name_html_a20e78764d5aab84abdc052ea3e43a965"><div class="ttname"><a href="structpvr_1_1utils_1_1_vertex_bindings___name.html#a20e78764d5aab84abdc052ea3e43a965">pvr::utils::VertexBindings_Name::semantic</a></div><div class="ttdeci">StringHash semantic</div><div class="ttdoc">Effect semantic.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:885</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a3f241ba112200732fffaeb2906b6ed4b"><div class="ttname"><a href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">pvr::utils::beginCommandBufferDebugLabel</a></div><div class="ttdeci">void beginCommandBufferDebugLabel(pvrvk::CommandBufferBase commandBufferBase, const pvrvk::DebugUtilsLabel &amp;labelInfo)</div><div class="ttdoc">Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLab...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:107</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vertex_bindings___name_html"><div class="ttname"><a href="structpvr_1_1utils_1_1_vertex_bindings___name.html">pvr::utils::VertexBindings_Name</a></div><div class="ttdoc">Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:882</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_queue_populate_info_html_ad38c982d524591f2b715b130a8c9f697"><div class="ttname"><a href="structpvr_1_1utils_1_1_queue_populate_info.html#ad38c982d524591f2b715b130a8c9f697">pvr::utils::QueuePopulateInfo::priority</a></div><div class="ttdeci">float priority</div><div class="ttdoc">Specifies the priority which should be given to the retrieved queue.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:590</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_a74171c9f0e1ea8f1eac9a991349389a6"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#a74171c9f0e1ea8f1eac9a991349389a6">pvr::utils::ImageUpdateInfo::cubeFace</a></div><div class="ttdeci">uint32_t cubeFace</div><div class="ttdoc">Valid for Cube texture updates only. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:468</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a5d3d1522b9db9f69b91090f918ccc8c0"><div class="ttname"><a href="namespacepvr_1_1utils.html#a5d3d1522b9db9f69b91090f918ccc8c0">pvr::utils::generateTextureAtlas</a></div><div class="ttdeci">void generateTextureAtlas(pvrvk::Device &amp;device, const pvrvk::Image *inputImages, pvrvk::Rect2Df *outUVs, uint32_t numImages, pvrvk::ImageLayout inputImageLayout, pvrvk::ImageView *outImageView, TextureHeader *outDescriptor, pvrvk::CommandBufferBase cmdBuffer, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</div><div class="ttdoc">Utility function for generating a texture atlas based on a set of images.</div></div>
<div class="ttc" id="_memory_allocator_8h_html_a0e66dd42c1b9d1bb7759aafd399bf5c1"><div class="ttname"><a href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">pvr::utils::vma::AllocationCreateFlags</a></div><div class="ttdeci">AllocationCreateFlags</div><div class="ttdoc">The AllocationCreateFlags enum set defines a set of flags which may effect the way in which the devic...</div><div class="ttdef"><b>Definition:</b> MemoryAllocator.h:105</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_queue_access_info_html_a6d0e303c656d8312932d268db869596a"><div class="ttname"><a href="structpvr_1_1utils_1_1_queue_access_info.html#a6d0e303c656d8312932d268db869596a">pvr::utils::QueueAccessInfo::familyId</a></div><div class="ttdeci">uint32_t familyId</div><div class="ttdoc">The queue family identifier the queue with queueId was retrieved from.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:609</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a1e9a18d03439c5efe7d88dbb3c16b783"><div class="ttname"><a href="namespacepvr_1_1utils.html#a1e9a18d03439c5efe7d88dbb3c16b783">pvr::utils::populateViewportStateCreateInfo</a></div><div class="ttdeci">void populateViewportStateCreateInfo(const pvrvk::Framebuffer &amp;framebuffer, pvrvk::PipelineViewportStateCreateInfo &amp;outCreateInfo)</div><div class="ttdoc">Fills out a pvrvk::ViewportStateCreateInfo structure setting parameters for a &amp;#39;default&amp;#39; viewport and ...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:864</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_queue_access_info_html_ae5df4d78d8d64b5009b8c5a9e36c0e23"><div class="ttname"><a href="structpvr_1_1utils_1_1_queue_access_info.html#ae5df4d78d8d64b5009b8c5a9e36c0e23">pvr::utils::QueueAccessInfo::queueId</a></div><div class="ttdeci">uint32_t queueId</div><div class="ttdoc">The queue identifier for the retrieved queue in queue family with identifier familyId.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:612</div></div>
<div class="ttc" id="classpvr_1_1_multi_html"><div class="ttname"><a href="classpvr_1_1_multi.html">pvr::Multi</a></div><div class="ttdoc">A small statically allocated array This class represents a small array of items. The array is statica...</div><div class="ttdef"><b>Definition:</b> MultiObject.h:17</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a06f94be9a865755c8bafaac56f286b01"><div class="ttname"><a href="namespacepvr_1_1utils.html#a06f94be9a865755c8bafaac56f286b01">pvr::utils::createSingleBuffersFromMeshes</a></div><div class="ttdeci">void createSingleBuffersFromMeshes(pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboInsertIterator_ outVbos, IboInsertIterator_ outIbos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="ttdoc">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1115</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vulkan_version_html_a6c8a350c06cf3c659a092f0688f860b2"><div class="ttname"><a href="structpvr_1_1utils_1_1_vulkan_version.html#a6c8a350c06cf3c659a092f0688f860b2">pvr::utils::VulkanVersion::minorV</a></div><div class="ttdeci">uint32_t minorV</div><div class="ttdoc">The minor version number.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1420</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a98e4ac9990af6eaf6b9bf0928f2bd07d"><div class="ttname"><a href="namespacepvr_1_1utils.html#a98e4ac9990af6eaf6b9bf0928f2bd07d">pvr::utils::populateClearValues</a></div><div class="ttdeci">void populateClearValues(const pvrvk::RenderPass &amp;renderpass, const pvrvk::ClearValue &amp;clearColor, const pvrvk::ClearValue &amp;clearDepthStencilValue, pvrvk::ClearValue *outClearValues)</div><div class="ttdoc">Populate color and depthstencil clear values</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1329</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_a7088e032f08263a7d72acafbd6c93fca"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#a7088e032f08263a7d72acafbd6c93fca">pvr::utils::ImageUpdateInfo::dataHeight</a></div><div class="ttdeci">uint32_t dataHeight</div><div class="ttdoc">Valid for 2D, 3D and Cube texture updates. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:465</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a3c7a82ad08f5f77c574a75fc1c4eca9a"><div class="ttname"><a href="namespacepvr_1_1utils.html#a3c7a82ad08f5f77c574a75fc1c4eca9a">pvr::utils::createDebugUtilsCallbacks</a></div><div class="ttdeci">DebugUtilsCallbacks createDebugUtilsCallbacks(pvrvk::Instance &amp;instance)</div><div class="ttdoc">Creates a default set of debug utils messengers or debug callbacks using either VK_EXT_debug_utils or...</div></div>
<div class="ttc" id="namespacepvr_html"><div class="ttname"><a href="namespacepvr.html">pvr</a></div><div class="ttdoc">Main PowerVR Framework namespace</div><div class="ttdef"><b>Definition:</b> EglPlatformContext.h:21</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a56ce1f5bcf625224715988176c3519a2"><div class="ttname"><a href="namespacepvr_1_1utils.html#a56ce1f5bcf625224715988176c3519a2">pvr::utils::getColorBits</a></div><div class="ttdeci">void getColorBits(pvrvk::Format format, uint32_t &amp;redBits, uint32_t &amp;greenBits, uint32_t &amp;blueBits, uint32_t &amp;alphaBits)</div><div class="ttdoc">Determines the number of color bits per pixel for the given pvrvk::Format.</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a116badc6ed0a108f3cc8ea515283a458"><div class="ttname"><a href="namespacepvr_1_1utils.html#a116badc6ed0a108f3cc8ea515283a458">pvr::utils::convertToPVRVkVertexInputFormat</a></div><div class="ttdeci">pvrvk::Format convertToPVRVkVertexInputFormat(DataType dataType, uint8_t width)</div><div class="ttdoc">Convert to pvrvk format</div><div class="ttdef"><b>Definition:</b> ConvertToPVRVkTypes.h:101</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_acd56ceb5a0ccd36437b833a00a1bd9c5"><div class="ttname"><a href="namespacepvr_1_1utils.html#acd56ceb5a0ccd36437b833a00a1bd9c5">pvr::utils::saveImage</a></div><div class="ttdeci">void saveImage(pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Image &amp;image, const pvrvk::ImageLayout imageInitialLayout, const pvrvk::ImageLayout imageFinalLayout, const std::string &amp;filename, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, const uint32_t screenshotScale=1)</div><div class="ttdoc">Saves the input image as a TGA file with the filename specified. Note that the image must have been c...</div></div>
<div class="ttc" id="classpvr_1_1_multi_html_a2e662f3b39e54e6995421a1f15ed9103"><div class="ttname"><a href="classpvr_1_1_multi.html#a2e662f3b39e54e6995421a1f15ed9103">pvr::Multi::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdoc">Number of items currently held in the object</div><div class="ttdef"><b>Definition:</b> MultiObject.h:58</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vulkan_version_html_a3e1b806e01b77ae8589182a3d55cb00d"><div class="ttname"><a href="structpvr_1_1utils_1_1_vulkan_version.html#a3e1b806e01b77ae8589182a3d55cb00d">pvr::utils::VulkanVersion::patchV</a></div><div class="ttdeci">uint32_t patchV</div><div class="ttdoc">The patch version number.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1422</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_ae8eb6603e41f6af5b9ddfbe6d6485570"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#ae8eb6603e41f6af5b9ddfbe6d6485570">pvr::utils::ImageUpdateInfo::imageWidth</a></div><div class="ttdeci">uint32_t imageWidth</div><div class="ttdoc">Valid for all. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:455</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vulkan_version_html_a93aa7e756fb29313e3556bb4f5c10f3a"><div class="ttname"><a href="structpvr_1_1utils_1_1_vulkan_version.html#a93aa7e756fb29313e3556bb4f5c10f3a">pvr::utils::VulkanVersion::VulkanVersion</a></div><div class="ttdeci">VulkanVersion(uint32_t majorV=1, uint32_t minorV=1, uint32_t patchV=0)</div><div class="ttdoc">Default constructor for the VulkanVersion structure initiailising the version to the first Vulkan rel...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1428</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_instance_layers_html"><div class="ttname"><a href="structpvr_1_1utils_1_1_instance_layers.html">pvr::utils::InstanceLayers</a></div><div class="ttdoc">Container for a list of instance layers to be used for initiailising an instance using the helper fun...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:619</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_device_extensions_html"><div class="ttname"><a href="structpvr_1_1utils_1_1_device_extensions.html">pvr::utils::DeviceExtensions</a></div><div class="ttdoc">Container for a list of device extensions to be used for initiailising a device using the helper func...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:640</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a34226196d1cd435e8f19abecc2d3b0eb"><div class="ttname"><a href="namespacepvr_1_1utils.html#a34226196d1cd435e8f19abecc2d3b0eb">pvr::utils::createDeviceAndQueues</a></div><div class="ttdeci">pvrvk::Device createDeviceAndQueues(pvrvk::PhysicalDevice physicalDevice, const QueuePopulateInfo *queueCreateInfos, uint32_t numQueueCreateInfos, QueueAccessInfo *outAccessInfo, const DeviceExtensions &amp;deviceExtensions=DeviceExtensions())</div><div class="ttdoc">Create the pvrvk::Device and the queues</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vulkan_version_html_ae034e617f8481394b0d37b6ddaa228fd"><div class="ttname"><a href="structpvr_1_1utils_1_1_vulkan_version.html#ae034e617f8481394b0d37b6ddaa228fd">pvr::utils::VulkanVersion::majorV</a></div><div class="ttdeci">uint32_t majorV</div><div class="ttdoc">The major version number.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1418</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_aee21903727c73558ad8e3cf936917344"><div class="ttname"><a href="namespacepvr_1_1utils.html#aee21903727c73558ad8e3cf936917344">pvr::utils::mapDebugReportFlagsToLogLevel</a></div><div class="ttdeci">LogLevel mapDebugReportFlagsToLogLevel(pvrvk::DebugReportFlagsEXT flags)</div><div class="ttdoc">Maps a set of DebugReportFlagsEXT to a particular type of log message.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1357</div></div>
<div class="ttc" id="_memory_allocator_8h_html_aad694c017b2fdbb822163769e1ebeb64"><div class="ttname"><a href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">pvr::utils::vma::Allocator</a></div><div class="ttdeci">std::shared_ptr&lt; impl::Allocator_ &gt; Allocator</div><div class="ttdoc">Forwared-declared reference-counted handle to a Allocator. For detailed documentation, see below</div><div class="ttdef"><b>Definition:</b> MemoryAllocator.h:78</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a3555f264beaaf83ff1b84853a87a40fe"><div class="ttname"><a href="namespacepvr_1_1utils.html#a3555f264beaaf83ff1b84853a87a40fe">pvr::utils::getPerspectiveMatrix</a></div><div class="ttdeci">glm::mat4 getPerspectiveMatrix(float fovy, float aspect, float near1, float far1, float rotate=.0f)</div><div class="ttdoc">Create perspective matrix that trasform scenes that use Opengl Convention (+y up) to Vulkan Conventio...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:234</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_instance_extensions_html"><div class="ttname"><a href="structpvr_1_1utils_1_1_instance_extensions.html">pvr::utils::InstanceExtensions</a></div><div class="ttdoc">Container for a list of instance extensions to be used for initiailising an instance using the helper...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:633</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a3d992b548d4b9d5617bc2766f1dbdda9"><div class="ttname"><a href="namespacepvr_1_1utils.html#a3d992b548d4b9d5617bc2766f1dbdda9">pvr::utils::createSwapchain</a></div><div class="ttdeci">pvrvk::Swapchain createSwapchain(pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, const std::vector&lt; pvrvk::Format &gt; &amp;preferredColorFormats=std::vector&lt; pvrvk::Format &gt;(), pvrvk::ImageUsageFlags swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT)</div><div class="ttdoc">Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface choosing the color...</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_ac885b6f537cb86c114be6696c3dc2fb6"><div class="ttname"><a href="namespacepvr_1_1utils.html#ac885b6f537cb86c114be6696c3dc2fb6">pvr::utils::updateBufferUsingStagingBuffer</a></div><div class="ttdeci">void updateBufferUsingStagingBuffer(pvrvk::Device &amp;device, pvrvk::Buffer &amp;buffer, pvrvk::CommandBufferBase uploadCmdBuffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, vma::Allocator *stagingBufferAllocator=nullptr)</div><div class="ttdoc">Utility function to update a buffer&amp;#39;s data via an indirect copy from a temporary staging buffer...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:535</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a076fe31eafd575f7f2a10f27f6130935"><div class="ttname"><a href="namespacepvr_1_1utils.html#a076fe31eafd575f7f2a10f27f6130935">pvr::utils::setImageLayout</a></div><div class="ttdeci">void setImageLayout(pvrvk::Image &amp;image, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::CommandBufferBase transitionCmdBuffer)</div><div class="ttdoc">Set image layout</div><div class="ttdef"><b>Definition:</b> HelperVk.h:263</div></div>
<div class="ttc" id="classpvr_1_1_multi_html_a689f8a2da8d7decb53b75af7732c570d"><div class="ttname"><a href="classpvr_1_1_multi.html#a689f8a2da8d7decb53b75af7732c570d">pvr::Multi::resize</a></div><div class="ttdeci">void resize(uint32_t newsize)</div><div class="ttdoc">Set the number of items held in the object</div><div class="ttdef"><b>Definition:</b> MultiObject.h:63</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a391224081fe950b01072c76a7a33fbac"><div class="ttname"><a href="namespacepvr_1_1utils.html#a391224081fe950b01072c76a7a33fbac">pvr::utils::createSwapchainAndDepthStencilImageAndViews</a></div><div class="ttdeci">void createSwapchainAndDepthStencilImageAndViews(pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::Swapchain &amp;outSwapchain, Multi&lt; pvrvk::ImageView &gt; &amp;outDepthStencilImages, const std::vector&lt; pvrvk::Format &gt; &amp;preferredColorFormats=std::vector&lt; pvrvk::Format &gt;(), const std::vector&lt; pvrvk::Format &gt; &amp;preferredDepthStencilFormats=std::vector&lt; pvrvk::Format &gt;(), const pvrvk::ImageUsageFlags &amp;swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const pvrvk::ImageUsageFlags &amp;dsImageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, vma::Allocator *dsImageAllocator=nullptr, vma::AllocationCreateFlags dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</div><div class="ttdoc">Create a pvrvk::Swapchain and corresponding number of depth stencil images using a pre-initialised pv...</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a1cbbbd1665449ea70d772de63595c806"><div class="ttname"><a href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">pvr::utils::logMessageDebugReportCallback</a></div><div class="ttdeci">VKAPI_ATTR VkBool32 VKAPI_CALL logMessageDebugReportCallback(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</div><div class="ttdoc">An application DebugReportCallback function providing logging for various events.</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a19f7af5558e7afc812edc1e8899d8f50"><div class="ttname"><a href="namespacepvr_1_1utils.html#a19f7af5558e7afc812edc1e8899d8f50">pvr::utils::setImageLayoutAndQueueFamilyOwnership</a></div><div class="ttdeci">void setImageLayoutAndQueueFamilyOwnership(pvrvk::CommandBufferBase srccmd, pvrvk::CommandBufferBase dstcmd, uint32_t srcQueueFamily, uint32_t dstQueueFamily, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::Image &amp;image, uint32_t baseMipLevel, uint32_t numMipLevels, uint32_t baseArrayLayer, uint32_t numArrayLayers, pvrvk::ImageAspectFlags aspect)</div><div class="ttdoc">Set image layout and queue family ownership</div></div>
<div class="ttc" id="namespacepvr_1_1ui_html_a53dcd60295ba8451f90e60213d82b2e8"><div class="ttname"><a href="namespacepvr_1_1ui.html#a53dcd60295ba8451f90e60213d82b2e8">pvr::ui::Image</a></div><div class="ttdeci">std::shared_ptr&lt; impl::Image_ &gt; Image</div><div class="ttdoc">A Reference Counted Framework Object wrapping the Image_ class. The Image is a Sprite and contains a ...</div><div class="ttdef"><b>Definition:</b> SpriteGles.h:85</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a618e4160bd8c24d9e0d394dc9511f4a3"><div class="ttname"><a href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">pvr::utils::updateHostVisibleBuffer</a></div><div class="ttdeci">void updateHostVisibleBuffer(pvrvk::Buffer &amp;buffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, bool flushMemory=false)</div><div class="ttdoc">Utility function to update a buffer&amp;#39;s data. This function maps and unmap the buffer only if the buffe...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:504</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_a3bae3542769781673b17522db91c19b0"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#a3bae3542769781673b17522db91c19b0">pvr::utils::ImageUpdateInfo::offsetY</a></div><div class="ttdeci">int32_t offsetY</div><div class="ttdoc">Valid for 2D, 3D and Cube texture updates. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:463</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_abbd1f30f49a0d36c9d932437e902d2bb"><div class="ttname"><a href="namespacepvr_1_1utils.html#abbd1f30f49a0d36c9d932437e902d2bb">pvr::utils::mapDebugUtilsMessageSeverityFlagsToLogLevel</a></div><div class="ttdeci">LogLevel mapDebugUtilsMessageSeverityFlagsToLogLevel(pvrvk::DebugUtilsMessageSeverityFlagsEXT flags)</div><div class="ttdoc">Maps a set of DebugUtilsMessageSeverityFlagsEXT to a particular type of log message.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1345</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_a1b452f639a4e507f7d3bdfaf529da029"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#a1b452f639a4e507f7d3bdfaf529da029">pvr::utils::ImageUpdateInfo::mipLevel</a></div><div class="ttdeci">uint32_t mipLevel</div><div class="ttdoc">Valid for all. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:458</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a94564335e1a4bb4afe501e4b90c9c25e"><div class="ttname"><a href="namespacepvr_1_1utils.html#a94564335e1a4bb4afe501e4b90c9c25e">pvr::utils::uploadImage</a></div><div class="ttdeci">pvrvk::Image uploadImage(pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</div><div class="ttdoc">Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_queue_access_info_html_a01adf09947e46f17ac7f924a3b5186f2"><div class="ttname"><a href="structpvr_1_1utils_1_1_queue_access_info.html#a01adf09947e46f17ac7f924a3b5186f2">pvr::utils::QueueAccessInfo::QueueAccessInfo</a></div><div class="ttdeci">QueueAccessInfo()</div><div class="ttdoc">Constructor for a QueueAccessInfo which sets family id and queue id to invalid values.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:615</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a73851a7eda7a39c5f4e8449ec08ba561"><div class="ttname"><a href="namespacepvr_1_1utils.html#a73851a7eda7a39c5f4e8449ec08ba561">pvr::utils::createSurface</a></div><div class="ttdeci">pvrvk::Surface createSurface(pvrvk::Instance &amp;instance, pvrvk::PhysicalDevice &amp;physicalDevice, void *window, void *display, void *connection)</div><div class="ttdoc">Creates an abstract vulkan native platform surface.</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a5e37e4f2f8723d81f2f60ff7c9ffebdf"><div class="ttname"><a href="namespacepvr_1_1utils.html#a5e37e4f2f8723d81f2f60ff7c9ffebdf">pvr::utils::logMessageDebugUtilsMessengerCallback</a></div><div class="ttdeci">VKAPI_ATTR VkBool32 VKAPI_CALL logMessageDebugUtilsMessengerCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</div><div class="ttdoc">An application DebugUtilsMessengerCallback function providing logging for various events...</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_queue_populate_info_html_ab303d9a7f5c55fcd9a13f272ae23b764"><div class="ttname"><a href="structpvr_1_1utils_1_1_queue_populate_info.html#ab303d9a7f5c55fcd9a13f272ae23b764">pvr::utils::QueuePopulateInfo::surface</a></div><div class="ttdeci">pvrvk::Surface surface</div><div class="ttdoc">Indicates that the retrieved queue must support presentation to the provided surface.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:587</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_af9bdb2f2512ec72d5669ae3b870d7fa5"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#af9bdb2f2512ec72d5669ae3b870d7fa5">pvr::utils::ImageUpdateInfo::offsetZ</a></div><div class="ttdeci">int32_t offsetZ</div><div class="ttdoc">Valid for 3D texture updates only. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:471</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_ae6934715b675cba2e0a7454813b431a3"><div class="ttname"><a href="namespacepvr_1_1utils.html#ae6934715b675cba2e0a7454813b431a3">pvr::utils::createSingleBuffersFromMesh</a></div><div class="ttdeci">void createSingleBuffersFromMesh(pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, pvrvk::Buffer &amp;outVbo, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="ttdoc">Auto generates a single VBO and a single IBO from all the vertex data of a mesh.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:981</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vulkan_version_html_a4a7dfa46502a507457263578dd48e572"><div class="ttname"><a href="structpvr_1_1utils_1_1_vulkan_version.html#a4a7dfa46502a507457263578dd48e572">pvr::utils::VulkanVersion::toVulkanVersion</a></div><div class="ttdeci">uint32_t toVulkanVersion()</div><div class="ttdoc">Converts the major, minor and patch versions to a uint32_t which can be directly used when creating a...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1432</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html">pvr::utils::ImageUpdateInfo</a></div><div class="ttdoc">The ImageUpdateInfo struct.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:451</div></div>
<div class="ttc" id="_memory_allocator_8h_html"><div class="ttname"><a href="_memory_allocator_8h.html">MemoryAllocator.h</a></div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a95e0a5be7c444548e52a74c2f40faaa5"><div class="ttname"><a href="namespacepvr_1_1utils.html#a95e0a5be7c444548e52a74c2f40faaa5">pvr::utils::createMultipleBuffersFromMesh</a></div><div class="ttdeci">void createMultipleBuffersFromMesh(pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, std::vector&lt; pvrvk::Buffer &gt; &amp;outVbos, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator *bufferAllocator, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</div><div class="ttdoc">Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1050</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_queue_populate_info_html_a8f6a04a2c21acef02ed848f4de285643"><div class="ttname"><a href="structpvr_1_1utils_1_1_queue_populate_info.html#a8f6a04a2c21acef02ed848f4de285643">pvr::utils::QueuePopulateInfo::queueFlags</a></div><div class="ttdeci">pvrvk::QueueFlags queueFlags</div><div class="ttdoc">The queue flags the queue must support.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:584</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_aaf3d187bfb119271fea887f28268699a"><div class="ttname"><a href="namespacepvr_1_1utils.html#aaf3d187bfb119271fea887f28268699a">pvr::utils::throwOnErrorDebugUtilsMessengerCallback</a></div><div class="ttdeci">VKAPI_ATTR VkBool32 VKAPI_CALL throwOnErrorDebugUtilsMessengerCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</div><div class="ttdoc">An application DebugUtilsMessengerCallback function providing logging for various events...</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_queue_access_info_html"><div class="ttname"><a href="structpvr_1_1utils_1_1_queue_access_info.html">pvr::utils::QueueAccessInfo</a></div><div class="ttdoc">A structure encapsulating the family id and queue id of a particular queue retrieved via the helper f...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:606</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a9bf319f2a39bf8149f2c8c4b36b1382a"><div class="ttname"><a href="namespacepvr_1_1utils.html#a9bf319f2a39bf8149f2c8c4b36b1382a">pvr::utils::loadAndUploadImage</a></div><div class="ttdeci">pvrvk::Image loadAndUploadImage(pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</div><div class="ttdoc">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffe...</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_vertex_bindings_html_a0179ccaad4acf5af997d6f1032b13404"><div class="ttname"><a href="structpvr_1_1utils_1_1_vertex_bindings.html#a0179ccaad4acf5af997d6f1032b13404">pvr::utils::VertexBindings::location</a></div><div class="ttdeci">int16_t location</div><div class="ttdoc">shader attribute location.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:878</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_debug_utils_callbacks_html"><div class="ttname"><a href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">pvr::utils::DebugUtilsCallbacks</a></div><div class="ttdoc">A simple wrapper structure which provides a more abstract representation of a set of debug utils mess...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:69</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a605300322093e44b7cd509533f14b4fa"><div class="ttname"><a href="namespacepvr_1_1utils.html#a605300322093e44b7cd509533f14b4fa">pvr::utils::endQueueDebugLabel</a></div><div class="ttdeci">void endQueueDebugLabel(pvrvk::Queue queue)</div><div class="ttdoc">Ends a label region of work submitted to this queue.</div><div class="ttdef"><b>Definition:</b> HelperVk.h:97</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_af132fea9e3e9e5b4bc87004a4228096a"><div class="ttname"><a href="namespacepvr_1_1utils.html#af132fea9e3e9e5b4bc87004a4228096a">pvr::utils::takeScreenshot</a></div><div class="ttdeci">bool takeScreenshot(pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Swapchain &amp;swapchain, const uint32_t swapIndex, const std::string &amp;screenshotFileName, vma::Allocator *bufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, const uint32_t screenshotScale=1)</div><div class="ttdoc">Saves a particular swapchain image corresponding to the swapchain image at index swapIndex for the sw...</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a4275d35b8141132ad949ef9d8ad0f5a2"><div class="ttname"><a href="namespacepvr_1_1utils.html#a4275d35b8141132ad949ef9d8ad0f5a2">pvr::utils::uploadImageAndViewSubmit</a></div><div class="ttdeci">pvrvk::ImageView uploadImageAndViewSubmit(pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandPool &amp;commandPool, pvrvk::Queue &amp;queue, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator *stagingBufferAllocator=nullptr, vma::Allocator *imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</div><div class="ttdoc">Uploads an image to GPU memory and returns the created image view and associated image.</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_debug_utils_callbacks_html_aeb1f89203f5e3397200ff8b491810dea"><div class="ttname"><a href="structpvr_1_1utils_1_1_debug_utils_callbacks.html#aeb1f89203f5e3397200ff8b491810dea">pvr::utils::DebugUtilsCallbacks::debugUtilsMessengers</a></div><div class="ttdeci">pvrvk::DebugUtilsMessenger debugUtilsMessengers[2]</div><div class="ttdoc">A set of debug utils messengers which may be used when VK_EXT_debug_utils is supported and enabled vi...</div><div class="ttdef"><b>Definition:</b> HelperVk.h:73</div></div>
<div class="ttc" id="namespacepvr_1_1utils_html_a7151c7b74ff657fc17ff09c0ab114a07"><div class="ttname"><a href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07">pvr::utils::isFormatDepthStencil</a></div><div class="ttdeci">bool isFormatDepthStencil(pvrvk::Format format)</div><div class="ttdoc">Return true if the format is a depth stencil format</div><div class="ttdef"><b>Definition:</b> HelperVk.h:1320</div></div>
<div class="ttc" id="structpvr_1_1utils_1_1_image_update_info_html_a9c2480ee85781549db081da54c7cbf7b"><div class="ttname"><a href="structpvr_1_1utils_1_1_image_update_info.html#a9c2480ee85781549db081da54c7cbf7b">pvr::utils::ImageUpdateInfo::offsetX</a></div><div class="ttdeci">int32_t offsetX</div><div class="ttdoc">Valid for all. </div><div class="ttdef"><b>Definition:</b> HelperVk.h:454</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
