#version 310 es
// Autogenerated

uniform layout(rgba16f, binding = 0) readonly mediump image2D imageIn;
uniform layout(rgba16f, binding = 1) writeonly mediump image2D imageOut;

// Offsets generated using generateGaussianCoefficients and generateGaussianWeightsAndOffsetsStrings()
// Number of iterations
// Example: const uint numIterations = 3;
%s
// Duplicated Weights used for the Gaussian Blur
// Example: const mediump float gWeights[numIterations * 2] = {0.25, 0.5, 0.25, 0.25, 0.5, 0.25};
%s

layout(local_size_x = 32, local_size_y = 1) in;

void main()
{
	uvec2 image_bounds = uvec2(imageSize(imageIn));

	uint fptr = 0u; // Counter tracking the last item in our cache
	uint x = 0u; // Counter (Calculated from fpts) used to find which item in the weights array each color in the cache corresponds to

	// This is our per-row cache of colors. We use the previous numbers to check what we must load or discard.
	// Example: mediump float f[numIterations * 2] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	%s

	uint column = gl_GlobalInvocationID.x;

	uint halfKernelIndex = uint(float(numIterations - 1u) * 0.5);

	uint offset = 0u;
	for (uint i = halfKernelIndex; i < numIterations; ++i)
	{
		f[i] = imageLoad(imageIn, ivec2(int(column), int(offset))).r;
		offset++;
	}

	for (uint i = 0u; i < halfKernelIndex; ++i)
	{
		f[i] = f[halfKernelIndex];
	}

	mediump float rowAverage = 0.0;

	// Scan the image top-to-bottom (one invocation must be launched for each column of the image)
	for (uint rowIndex = 0u; rowIndex < image_bounds.x; ++rowIndex)
	{
		// Average the color. X tracks the which item in the weight array corresponds to each item in the color array
		// IMPORTANT NOTE: We do not need bounds checking or expensive modulo operations here, because we have made sure
		// the weight array is doubled.
		rowAverage = 0.0;

		for (uint i = 0u; i < numIterations; ++i)
		{
			rowAverage += f[i] * gWeights[i + x];
		}

		imageStore(imageOut, ivec2(int(column), int(rowIndex)), vec4(rowAverage, 0.0, 0.0, 0.0)); // STORE INTO THE OUTPUT IMAGE.

		uint row_to_sample = rowIndex + halfKernelIndex + 1u; // Select the next texel to load.
		row_to_sample = min(row_to_sample, image_bounds.y - 1u);
		f[fptr++] = imageLoad(imageIn, ivec2(int(column), int(row_to_sample))).r; //Load the next texel replacing the oldest item in the array.
		x = numIterations - fptr; //Calculate the X factor (used to match which item in the weight array we must match to each item in the F array)
		if (fptr == numIterations) { fptr = 0u; }
	}
}