#version 310 es
// Autogenerated

uniform layout(rgba16f, binding = 0) readonly mediump image2D imageIn;
uniform layout(rgba16f, binding = 1) writeonly mediump image2D imageOut;

// Offsets generated using generateGaussianCoefficients and generateGaussianWeightsAndOffsetsStrings()
// Number of iterations
// Example: const uint numIterations = 3;
%s
// Duplicated Weights used for the Gaussian Blur
// Example: const mediump float gWeights[numIterations * 2] = {0.25, 0.5, 0.25, 0.25, 0.5, 0.25};
%s

layout(local_size_x = 32, local_size_y = 1) in;

void main()
{
	uvec2 image_bounds = uvec2(imageSize(imageIn));

	uint fptr = 0u; // Counter tracking the last item in our cache
	uint x = 0u; // Counter (Calculated from fpts) used to find which item in the weights array each color in the cache corresponds to

	// This is our per-row cache of colors. We use the previous numbers to check what we must load or discard.
	// Example: mediump float f[numIterations * 2] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	%s

	uint row = gl_GlobalInvocationID.x;

	uint halfKernelIndex = uint(float(numIterations - 1u) * 0.5);

	uint offset = 0u;
	for (uint i = halfKernelIndex; i < numIterations; ++i)
	{
		f[i] = imageLoad(imageIn, ivec2(int(offset), int(row))).r;
		offset++;
	}

	for (uint i = 0u; i < halfKernelIndex; ++i)
	{
		f[i] = f[halfKernelIndex];
	}

	mediump float columnAverage = 0.0;

	// Scan the image left-to-right (one invocation must be launched for each row of the image)
	for (uint columnIndex = 0u; columnIndex < image_bounds.x; ++columnIndex)
	{
		// Average the color. X tracks the which item in the weight array corresponds to each item in the color array
		// IMPORTANT NOTE: We do not need bounds checking or expensive modulo operations here, because we have made sure
		// the weight array is doubled.
		columnAverage = 0.0;

		for (uint i = 0u; i < numIterations; ++i)
		{
			columnAverage += f[i] * gWeights[i + x];
		}

		imageStore(imageOut, ivec2(int(columnIndex), int(row)), vec4(columnAverage, 0.0, 0.0, 0.0)); // STORE INTO THE OUTPUT IMAGE.

		uint column_to_sample = columnIndex + halfKernelIndex + 1u; // Select the next texel to load.
		column_to_sample = min(column_to_sample, image_bounds.x - 1u);
		f[fptr++] = imageLoad(imageIn, ivec2(int(column_to_sample), int(row))).r; //Load the next texel replacing the oldest item in the array.
		x = numIterations - fptr; //Calculate the X factor (used to match which item in the weight array we must match to each item in the F array)
		if (fptr == numIterations) { fptr = 0u; }
	}
}